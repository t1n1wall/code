diff -ur sys.orig/conf/files sys/conf/files
--- sys.orig/conf/files	2010-12-21 18:09:25.000000000 +0100
+++ sys/conf/files	2011-04-27 14:11:46.000000000 +0200
@@ -2981,3 +2981,5 @@
 dev/xen/netfront/netfront.c	optional xen | xenhvm
 dev/xen/xenpci/xenpci.c		optional xenpci
 dev/xen/xenpci/evtchn.c         optional xenpci
+contrib/ipfilter/netinet/ip_scan.c	optional ipfilter inet ipfilter_scan
+contrib/ipfilter/netinet/ip_rules.c	optional ipfilter inet ipfilter_compiled
diff -ur sys.orig/conf/options sys/conf/options
--- sys.orig/conf/options	2010-12-21 18:09:25.000000000 +0100
+++ sys/conf/options	2011-04-27 13:03:02.000000000 +0200
@@ -846,3 +846,12 @@
 SND_OLDSTEREO		opt_snd.h
 
 X86BIOS
+
+# extra option for IP Filter
+IPFILTER_SCAN	opt_ipfilter.h
+
+# extra option for IP Filter
+IPFILTER_SYNC	opt_ipfilter.h
+
+# extra option for IP Filter
+IPFILTER_COMPILED	opt_ipfilter.h
diff -ur sys.orig/contrib/ipfilter/netinet/fil.c sys/contrib/ipfilter/netinet/fil.c
--- sys.orig/contrib/ipfilter/netinet/fil.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/fil.c	2011-04-27 13:03:01.000000000 +0200
@@ -151,7 +151,5 @@
 #include "netinet/ipl.h"
 /* END OF INCLUDES */
 
-#include <machine/in_cksum.h>
-
 #if !defined(lint)
 static const char sccsid[] = "@(#)fil.c	1.36 6/5/96 (C) 1993-2000 Darren Reed";
@@ -235,6 +232,7 @@
 static	ipfunc_t	fr_findfunc __P((ipfunc_t));
 static	frentry_t	*fr_firewall __P((fr_info_t *, u_32_t *));
 static	int		fr_funcinit __P((frentry_t *fr));
+static	void		fr_getstat __P((struct friostat *, int));
 static	INLINE void	frpr_ah __P((fr_info_t *));
 static	INLINE void	frpr_esp __P((fr_info_t *));
 static	INLINE void	frpr_gre __P((fr_info_t *));
@@ -356,7 +354,7 @@
 static	INLINE void	frpr_udp6 __P((fr_info_t *));
 static	INLINE void	frpr_tcp6 __P((fr_info_t *));
 static	INLINE void	frpr_icmp6 __P((fr_info_t *));
-static	INLINE int	frpr_ipv6hdr __P((fr_info_t *));
+static	INLINE void	frpr_ipv6hdr __P((fr_info_t *));
 static	INLINE void	frpr_short6 __P((fr_info_t *, int));
 static	INLINE int	frpr_hopopts6 __P((fr_info_t *));
 static	INLINE int	frpr_mobility6 __P((fr_info_t *));
@@ -388,7 +386,7 @@
 
 /* ------------------------------------------------------------------------ */
 /* Function:    frpr_ipv6hdr                                                */
-/* Returns:     int    - 0 = IPv6 packet intact, -1 = packet lost           */
+/* Returns:     void                                                        */
 /* Parameters:  fin(I) - pointer to packet information                      */
 /*                                                                          */
 /* IPv6 Only                                                                */
@@ -397,7 +395,7 @@
 /* analyzer may pullup or free the packet itself so we need to be vigiliant */
 /* of that possibility arising.                                             */
 /* ------------------------------------------------------------------------ */
-static INLINE int frpr_ipv6hdr(fin)
+static INLINE void frpr_ipv6hdr(fin)
 fr_info_t *fin;
 {
 	ip6_t *ip6 = (ip6_t *)fin->fin_ip;
@@ -418,7 +416,7 @@
 	fin->fin_id = (u_short)(ip6->ip6_flow & 0xffff);
 
 	hdrcount = 0;
-	while (go && !(fin->fin_flx & (FI_BAD|FI_SHORT))) {
+	while (go && !(fin->fin_flx & FI_SHORT)) {
 		switch (p)
 		{
 		case IPPROTO_UDP :
@@ -507,16 +505,6 @@
 		}
 	}
 	fi->fi_p = p;
-
-	/*
-	 * Some of the above functions, like frpr_esp6(), can call fr_pullup
-	 * and destroy whatever packet was here.  The caller of this function
-	 * expects us to return -1 if there is a problem with fr_pullup.
-	 */
-	if (fin->fin_m == NULL)
-		return -1;
-
-	return 0;
 }
 
 
@@ -529,6 +517,12 @@
 /*              proto(I)    - protocol number for this extension header     */
 /*                                                                          */
 /* IPv6 Only                                                                */
+/* This function expects to find an IPv6 extension header at fin_dp.        */
+/* There must be at least 8 Bytes of data at fin_dp for there to be a valid */
+/* extension header present. If a good one is found, fin_dp is advanced to  */
+/* point at the first piece of data after the extension header, fin_exthdr  */
+/* points to the start of the extension header and the "protocol" of the    */
+/* *NEXT* header is returned.                                               */
 /* ------------------------------------------------------------------------ */
 static INLINE int frpr_ipv6exthdr(fin, multiple, proto)
 fr_info_t *fin;
@@ -639,12 +633,6 @@
 		 * which means it must be a multiple of 2 lots of 8 in length.
 		 */
 		fin->fin_flx |= FI_BAD;
-		/*
-		 * Compensate for the changes made in frpr_ipv6exthdr()
-		 */
-		fin->fin_dlen += 8 + (hdr->ip6e_len << 3);
-		fin->fin_dp = hdr;
-		return IPPROTO_NONE;
 	}
 
 	return hdr->ip6e_nxt;
@@ -669,35 +657,38 @@
 fr_info_t *fin;
 {
 	struct ip6_frag *frag;
-	int extoff;
 
 	fin->fin_flx |= FI_FRAG;
 
+	/*
+	 * A fragmented IPv6 packet implies that there must be something
+	 * else after the fragment.
+	 */
 	if (frpr_ipv6exthdr(fin, 0, IPPROTO_FRAGMENT) == IPPROTO_NONE)
 		return IPPROTO_NONE;
 
-	extoff = (char *)fin->fin_exthdr - (char *)fin->fin_dp;
-
-	if (frpr_pullup(fin, sizeof(*frag)) == -1)
-		return IPPROTO_NONE;
-
-	fin->fin_exthdr = (char *)fin->fin_dp + extoff;
 	frag = fin->fin_exthdr;
+
 	/*
-	 * Fragment but no fragmentation info set?  Bad packet...
+	 * If this fragment isn't the last then the packet length must
+	 * be a multiple of 8.
 	 */
-	if (frag->ip6f_offlg == 0) {
-		fin->fin_flx |= FI_BAD;
-		return IPPROTO_NONE;
+	if ((frag->ip6f_offlg & IP6F_MORE_FRAG) != 0) {
+		fin->fin_flx |= FI_MOREFRAG;
+
+		if ((fin->fin_plen & 0x7) != 0)
+			fin->fin_flx |= FI_BAD;
 	}
 
 	fin->fin_off = ntohs(frag->ip6f_offlg & IP6F_OFF_MASK);
-	fin->fin_off <<= 3;
 	if (fin->fin_off != 0)
 		fin->fin_flx |= FI_FRAGBODY;
 
-	fin->fin_dp = (char *)fin->fin_dp + sizeof(*frag);
-	fin->fin_dlen -= sizeof(*frag);
+	/*
+	 * Jumbograms aren't handled, so the max. length is 64k
+	 */
+	if ((fin->fin_off << 3) + fin->fin_dlen > 65535)
+		fin->fin_flx |= FI_BAD;
 
 	return frag->ip6f_nxt;
 }
@@ -1006,84 +997,80 @@
 	if (frpr_pullup(fin, ICMPERR_ICMPHLEN) == -1)
 		return;
 
-	if (fin->fin_dlen > 1) {
-		icmp = fin->fin_dp;
-
-		fin->fin_data[0] = *(u_short *)icmp;
+	icmp = fin->fin_dp;
 
-		if (fin->fin_dlen >= 6)				/* ID field */
-			fin->fin_data[1] = icmp->icmp_id;
+	fin->fin_data[0] = *(u_short *)icmp;
+	fin->fin_data[1] = icmp->icmp_id;
 
-		switch (icmp->icmp_type)
-		{
-		case ICMP_ECHOREPLY :
-		case ICMP_ECHO :
-		/* Router discovery messaes - RFC 1256 */
-		case ICMP_ROUTERADVERT :
-		case ICMP_ROUTERSOLICIT :
-			minicmpsz = ICMP_MINLEN;
-			break;
+	switch (icmp->icmp_type)
+	{
+	case ICMP_ECHOREPLY :
+	case ICMP_ECHO :
+	/* Router discovery messaes - RFC 1256 */
+	case ICMP_ROUTERADVERT :
+	case ICMP_ROUTERSOLICIT :
+		minicmpsz = ICMP_MINLEN;
+		break;
+	/*
+	 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
+	 * 3 * timestamp(3 * 4)
+	 */
+	case ICMP_TSTAMP :
+	case ICMP_TSTAMPREPLY :
+		minicmpsz = 20;
+		break;
+	/*
+	 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
+	 * mask(4)
+	 */
+	case ICMP_MASKREQ :
+	case ICMP_MASKREPLY :
+		minicmpsz = 12;
+		break;
+	/*
+	 * type(1) + code(1) + cksum(2) + id(2) seq(2) + ip(20+)
+	 */
+	case ICMP_UNREACH :
+#ifdef icmp_nextmtu
+		if (icmp->icmp_code == ICMP_UNREACH_NEEDFRAG) {
+			if (icmp->icmp_nextmtu < fr_icmpminfragmtu)
+				fin->fin_flx |= FI_BAD;
+		}
+#endif
+	case ICMP_SOURCEQUENCH :
+	case ICMP_REDIRECT :
+	case ICMP_TIMXCEED :
+	case ICMP_PARAMPROB :
+		fin->fin_flx |= FI_ICMPERR;
+		if (fr_coalesce(fin) != 1)
+			return;
 		/*
-		 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
-		 * 3 * timestamp(3 * 4)
+		 * ICMP error packets should not be generated for IP
+		 * packets that are a fragment that isn't the first
+		 * fragment.
 		 */
-		case ICMP_TSTAMP :
-		case ICMP_TSTAMPREPLY :
-			minicmpsz = 20;
-			break;
+		oip = (ip_t *)((char *)fin->fin_dp + ICMPERR_ICMPHLEN);
+		if ((ntohs(oip->ip_off) & IP_OFFMASK) != 0)
+			fin->fin_flx |= FI_BAD;
+
 		/*
-		 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
-		 * mask(4)
+		 * If the destination of this packet doesn't match the
+		 * source of the original packet then this packet is
+		 * not correct.
 		 */
-		case ICMP_MASKREQ :
-		case ICMP_MASKREPLY :
-			minicmpsz = 12;
-			break;
+		if (oip->ip_src.s_addr != fin->fin_daddr)
+			fin->fin_flx |= FI_BAD;
+
 		/*
-		 * type(1) + code(1) + cksum(2) + id(2) seq(2) + ip(20+)
+		 * If the destination of this packet doesn't match the
+		 * source of the original packet then this packet is
+		 * not correct.
 		 */
-		case ICMP_UNREACH :
-#ifdef icmp_nextmtu
-			if (icmp->icmp_code == ICMP_UNREACH_NEEDFRAG) {
-				if (icmp->icmp_nextmtu < fr_icmpminfragmtu)
-					fin->fin_flx |= FI_BAD;
-			}
-#endif
-		case ICMP_SOURCEQUENCH :
-		case ICMP_REDIRECT :
-		case ICMP_TIMXCEED :
-		case ICMP_PARAMPROB :
-			fin->fin_flx |= FI_ICMPERR;
-			if (fr_coalesce(fin) != 1)
-				return;
-			/*
-			 * ICMP error packets should not be generated for IP
-			 * packets that are a fragment that isn't the first
-			 * fragment.
-			 */
-			oip = (ip_t *)((char *)fin->fin_dp + ICMPERR_ICMPHLEN);
-			if ((ntohs(oip->ip_off) & IP_OFFMASK) != 0)
-				fin->fin_flx |= FI_BAD;
-
-			/*
-			 * If the destination of this packet doesn't match the
-			 * source of the original packet then this packet is
-			 * not correct.
-			 */
-			if (oip->ip_src.s_addr != fin->fin_daddr)
-				fin->fin_flx |= FI_BAD;
-
-			/*
-			 * If the destination of this packet doesn't match the
-			 * source of the original packet then this packet is
-			 * not correct.
-			 */
-			if (oip->ip_src.s_addr != fin->fin_daddr)
-				fin->fin_flx |= FI_BAD;
-			break;
-		default :
-			break;
-		}
+		if (oip->ip_src.s_addr != fin->fin_daddr)
+			fin->fin_flx |= FI_BAD;
+		break;
+	default :
+		break;
 	}
 
 	frpr_short(fin, minicmpsz);
@@ -1459,16 +1446,18 @@
 		int morefrag = off & IP_MF;
 
 		fi->fi_flx |= FI_FRAG;
+		if (morefrag)
+			fi->fi_flx |= FI_MOREFRAG;
 		off &= IP_OFFMASK;
 		if (off != 0) {
 			fin->fin_flx |= FI_FRAGBODY;
 			off <<= 3;
-			if ((off + fin->fin_dlen > 65535) || 
+			if ((off + fin->fin_dlen > 65535) ||
 			    (fin->fin_dlen == 0) ||
 			    ((morefrag != 0) && ((fin->fin_dlen & 7) != 0))) {
-				/* 
+				/*
 				 * The length of the packet, starting at its
-				 * offset cannot exceed 65535 (0xffff) as the 
+				 * offset cannot exceed 65535 (0xffff) as the
 				 * length of an IP packet is only 16 bits.
 				 *
 				 * Any fragment that isn't the last fragment
@@ -1611,8 +1600,6 @@
 {
 	int v;
 
-	fin->fin_nat = NULL;
-	fin->fin_state = NULL;
 	fin->fin_depth = 0;
 	fin->fin_hlen = (u_short)hlen;
 	fin->fin_ip = ip;
@@ -1633,8 +1620,7 @@
 		fin->fin_dlen = fin->fin_plen;
 		fin->fin_plen += hlen;
 
-		if (frpr_ipv6hdr(fin) == -1)
-			return -1;
+		frpr_ipv6hdr(fin);
 #endif
 	}
 	if (fin->fin_ip == NULL)
@@ -2155,7 +2141,7 @@
 			 * the rule to "not match" and keep on processing
 			 * filter rules.
 			 */
-			if ((pass & FR_KEEPSTATE) &&
+			if ((pass & FR_KEEPSTATE) && !FR_ISAUTH(pass) &&
 			    !(fin->fin_flx & FI_STATE)) {
 				int out = fin->fin_out;
 
@@ -2277,6 +2263,12 @@
 		if (fin->fin_fr != NULL)
 			pass = fr_scanlist(fin, fr_pass);
 
+		fr = fin->fin_fr;
+		if ((fr != NULL) && (fr->fr_type == FR_T_IPF) &&
+		    ((fr->fr_satype == FRI_LOOKUP) ||
+		     (fr->fr_datype == FRI_LOOKUP)))
+			fin->fin_flx |= FI_DONTCACHE;
+
 		if (((pass & FR_KEEPSTATE) == 0) &&
 		    ((fin->fin_flx & FI_DONTCACHE) == 0)) {
 			WRITE_ENTER(&ipf_frcache);
@@ -2286,7 +2278,6 @@
 		if ((pass & FR_NOMATCH)) {
 			ATOMIC_INCL(frstats[out].fr_nom);
 		}
-		fr = fin->fin_fr;
 	}
 
 	/*
@@ -2428,10 +2419,7 @@
 	SPL_INT(s);
 # endif
 
-	READ_ENTER(&ipf_global);
-
 	if (fr_running <= 0) {
-		RWLOCK_EXIT(&ipf_global);
 		return 0;
 	}
 
@@ -2478,8 +2466,6 @@
 #  endif /* CSUM_DELAY_DATA */
 # endif /* MENTAT */
 #else
-	READ_ENTER(&ipf_global);
-
 	bzero((char *)fin, sizeof(*fin));
 	m = *mp;
 #endif /* _KERNEL */
@@ -2560,20 +2546,26 @@
 
 	READ_ENTER(&ipf_mutex);
 
+	if (!out) {
+		if (fr_checknatin(fin, &pass) == -1) {
+			goto filterdone;
+		}
+	}
+
 	/*
 	 * Check auth now.  This, combined with the check below to see if apass
 	 * is 0 is to ensure that we don't count the packet twice, which can
 	 * otherwise occur when we reprocess it.  As it is, we only count it
-	 * after it has no auth. table matchup.  This also stops NAT from
-	 * occuring until after the packet has been auth'd.
+	 * after it has no auth. table matchup.
+	 *
+	 * If a packet is found in the auth table, then skip checking
+	 * the access lists for permission but we do need to consider
+	 * the result as if it were from the ACL's.  In addition, being
+	 * found in the auth table means it has been seen before, so do
+	 * not pass it through accounting (again), lest it be counted twice.
 	 */
 	fr = fr_checkauth(fin, &pass);
-	if (!out) {
-		if (fr_checknatin(fin, &pass) == -1) {
-			goto filterdone;
-		}
-	}
-	if (!out)
+	if (!out && (fr == NULL))
 		(void) fr_acctpkt(fin, NULL);
 
 	if (fr == NULL) {
@@ -2647,22 +2639,9 @@
 	 * there is a similar flag, FI_NATED, for NAT, it does have the same
 	 * impact on code execution.
 	 */
-	if (fin->fin_state != NULL) {
-		fr_statederef((ipstate_t **)&fin->fin_state);
-		fin->fin_flx ^= FI_STATE;
-	}
-
-	if (fin->fin_nat != NULL) {
-		if (FR_ISBLOCK(pass) && (fin->fin_flx & FI_NEWNAT)) {
-			WRITE_ENTER(&ipf_nat);
-			nat_delete((nat_t *)fin->fin_nat, NL_DESTROY);
-			RWLOCK_EXIT(&ipf_nat);
-			fin->fin_nat = NULL;
-		} else {
-			fr_natderef((nat_t **)&fin->fin_nat);
-		}
-	}
+	fin->fin_flx &= ~FI_STATE;
 
+#if defined(FASTROUTE_RECURSION)
 	/*
 	 * Up the reference on fr_lock and exit ipf_mutex.  fr_fastroute
 	 * only frees up the lock on ipf_global and the generation of a
@@ -2677,6 +2656,7 @@
 	}
 
 	RWLOCK_EXIT(&ipf_mutex);
+#endif
 
 	if ((pass & FR_RETMASK) != 0) {
 		/*
@@ -2711,6 +2691,7 @@
 			 */
 			if (FR_ISAUTH(pass) && (fin->fin_m != NULL)) {
 				fin->fin_m = *fin->fin_mp = NULL;
+				m = NULL;
 			}
 		} else {
 			if (pass & FR_RETRST)
@@ -2718,6 +2699,9 @@
 		}
 	}
 
+	if (FR_ISBLOCK(pass) && (fin->fin_flx & FI_NEWNAT))
+		nat_uncreate(fin);
+
 	/*
 	 * If we didn't drop off the bottom of the list of rules (and thus
 	 * the 'current' rule fr is not NULL), then we may have some extra
@@ -2728,6 +2712,16 @@
 	if (fr != NULL) {
 		frdest_t *fdp;
 
+		/*
+		 * Generate a duplicated packet first because ipf_fastroute
+		 * can lead to fin_m being free'd... not good.
+		 */
+		if ((pass & FR_DUP) != 0) {
+			mc = M_DUPLICATE(fin->fin_m);
+			if (mc != NULL)
+				(void) fr_fastroute(mc, &mc, fin, &fr->fr_dif);
+		}
+
 		fdp = &fr->fr_tifs[fin->fin_rev];
 
 		if (!out && (pass & FR_FASTROUTE)) {
@@ -2744,17 +2738,13 @@
 			m = *mp = NULL;
 		}
 
-		/*
-		 * Generate a duplicated packet.
-		 */
-		if ((pass & FR_DUP) != 0) {
-			mc = M_DUPLICATE(fin->fin_m);
-			if (mc != NULL)
-				(void) fr_fastroute(mc, &mc, fin, &fr->fr_dif);
-		}
-
+#if defined(FASTROUTE_RECURSION)
 		(void) fr_derefrule(&fr);
+#endif
 	}
+#if !defined(FASTROUTE_RECURSION)
+	RWLOCK_EXIT(&ipf_mutex);
+#endif
 
 finished:
 	if (!FR_ISPASS(pass)) {
@@ -2774,7 +2764,6 @@
 	}
 
 	SPL_X(s);
-	RWLOCK_EXIT(&ipf_global);
 
 #ifdef _KERNEL
 # if (defined(OpenBSD) && (OpenBSD >= 200311))
@@ -3031,7 +3020,7 @@
 	}
 # else /* MENTAT */
 #  if defined(BSD) || defined(sun)
-#   if BSD >= 199103
+#   if defined(BSD) && (BSD >= 199103)
 	m->m_data += hlen;
 #   else
 	m->m_off += hlen;
@@ -3176,8 +3165,9 @@
 }
 
 
-#if defined(_KERNEL) && ( ((BSD < 199103) && !defined(MENTAT)) || \
-    defined(__sgi) ) && !defined(linux) && !defined(_AIX51)
+#if defined(_KERNEL) && ( ((defined(BSD) && (BSD < 199103)) && \
+    !defined(MENTAT)) || defined(__sgi) ) && \
+    !defined(linux) && !defined(_AIX51)
 /*
  * Copyright (c) 1982, 1986, 1988, 1991, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -3450,7 +3440,7 @@
 	fg = fr_findgroup(group, unit, fr_active, NULL);
 	if (fg == NULL)
 		return NULL;
-	for (fr = fg->fg_head; fr && n; fr = fr->fr_next, n--)
+	for (fr = fg->fg_start; fr && n; fr = fr->fr_next, n--)
 		;
 	if (n != 0)
 		return NULL;
@@ -3459,36 +3449,6 @@
 
 
 /* ------------------------------------------------------------------------ */
-/* Function:    fr_rulen                                                    */
-/* Returns:     int - >= 0 - rule number, -1 == search failed               */
-/* Parameters:  unit(I) - device for which to count the rule's number       */
-/*              fr(I)   - pointer to rule to match                          */
-/*                                                                          */
-/* Return the number for a rule on a specific filtering device.             */
-/* ------------------------------------------------------------------------ */
-int fr_rulen(unit, fr)
-int unit;
-frentry_t *fr;
-{
-	frentry_t *fh;
-	frgroup_t *fg;
-	u_32_t n = 0;
-
-	if (fr == NULL)
-		return -1;
-	fg = fr_findgroup(fr->fr_group, unit, fr_active, NULL);
-	if (fg == NULL)
-		return -1;
-	for (fh = fg->fg_head; fh; n++, fh = fh->fr_next)
-		if (fh == fr)
-			break;
-	if (fh == NULL)
-		return -1;
-	return n;
-}
-
-
-/* ------------------------------------------------------------------------ */
 /* Function:    frflushlist                                                 */
 /* Returns:     int - >= 0 - number of flushed rules                        */
 /* Parameters:  set(I)   - which set of rules (inactive/inactive) this is   */
@@ -3760,7 +3720,7 @@
 			fr->fr_ifas[i] = fr_resolvenic(fr->fr_ifnames[i], v);
 		}
 
-		if (fr->fr_type == FR_T_IPF) {
+		if ((fr->fr_type & ~FR_T_BUILTIN) == FR_T_IPF) {
 			if (fr->fr_satype != FRI_NORMAL &&
 			    fr->fr_satype != FRI_LOOKUP) {
 				(void)fr_ifpaddr(v, fr->fr_satype,
@@ -3794,15 +3754,15 @@
 		}
 
 #ifdef	IPFILTER_LOOKUP
-		if (fr->fr_type == FR_T_IPF && fr->fr_satype == FRI_LOOKUP &&
-		    fr->fr_srcptr == NULL) {
+		if (((fr->fr_type & ~FR_T_BUILTIN) == FR_T_IPF) &&
+		    (fr->fr_satype == FRI_LOOKUP) && (fr->fr_srcptr == NULL)) {
 			fr->fr_srcptr = fr_resolvelookup(fr->fr_srctype,
 							 fr->fr_srcsubtype,
 							 &fr->fr_slookup,
 							 &fr->fr_srcfunc);
 		}
-		if (fr->fr_type == FR_T_IPF && fr->fr_datype == FRI_LOOKUP &&
-		    fr->fr_dstptr == NULL) {
+		if (((fr->fr_type & ~FR_T_BUILTIN) == FR_T_IPF) &&
+		    (fr->fr_datype == FRI_LOOKUP) && (fr->fr_dstptr == NULL)) {
 			fr->fr_dstptr = fr_resolvelookup(fr->fr_dsttype,
 							 fr->fr_dstsubtype,
 							 &fr->fr_dlookup,
@@ -3950,12 +3910,18 @@
 /* Function:    fr_getstat                                                  */
 /* Returns:     Nil                                                         */
 /* Parameters:  fiop(I)  - pointer to ipfilter stats structure              */
+/*              rev(I)   - version of program doing ioctl                   */
 /*                                                                          */
 /* Stores a copy of current pointers, counters, etc, in the friostat        */
 /* structure.                                                               */
+/* If IPFILTER_COMPAT is compiled, we pretend to be whatever version the    */
+/* program is looking for. This ensure that validation of the version it    */
+/* expects will always succeed. Thus kernels with IPFILTER_COMPAT will      */
+/* allow older binaries to work but kernels without it will not.            */
 /* ------------------------------------------------------------------------ */
-void fr_getstat(fiop)
+static void fr_getstat(fiop, rev)
 friostat_t *fiop;
+int rev;
 {
 	int i, j;
 
@@ -3990,8 +3956,18 @@
 #endif
 	fiop->f_defpass = fr_pass;
 	fiop->f_features = fr_features;
+
+
+#ifdef IPFILTER_COMPAT
+	sprintf(fiop->f_version, "IP Filter: v%d.%d.%d",
+		       (rev / 1000000) % 100,
+		       (rev / 10000) % 100,
+		       (rev / 100) % 100);
+#else
+	rev = rev;
 	(void) strncpy(fiop->f_version, ipfilter_version,
 		       sizeof(fiop->f_version));
+#endif
 }
 
 
@@ -4197,7 +4173,7 @@
 caddr_t data;
 {
 	frentry_t frd, *fp, *f, **fprev, **ftail;
-	int error = 0, in, v;
+	int error = 0, in, v, need_free = 0;
 	void *ptr, *uptr;
 	u_int *p, *pp;
 	frgroup_t *fg;
@@ -4206,10 +4182,10 @@
 	fg = NULL;
 	fp = &frd;
 	if (makecopy != 0) {
-		error = fr_inobj(data, fp, IPFOBJ_FRENTRY);
+		error = fr_inobj(data, NULL, fp, IPFOBJ_FRENTRY);
 		if (error)
 			return EFAULT;
-		if ((fp->fr_flags & FR_T_BUILTIN) != 0)
+		if ((fp->fr_type & FR_T_BUILTIN) != 0)
 			return EINVAL;
 		fp->fr_ref = 0;
 		fp->fr_flags |= FR_COPIED;
@@ -4319,7 +4295,6 @@
 				error = EFAULT;
 		} else {
 			ptr = uptr;
-			error = 0;
 		}
 		if (error != 0) {
 			KFREES(ptr, fp->fr_dsize);
@@ -4331,24 +4306,20 @@
 
 	/*
 	 * Perform per-rule type sanity checks of their members.
+	 * All code after this needs to be aware that allocated memory
+	 * may need to be free'd before exiting.
 	 */
 	switch (fp->fr_type & ~FR_T_BUILTIN)
 	{
 #if defined(IPFILTER_BPF)
 	case FR_T_BPFOPC :
-		if (fp->fr_dsize == 0)
-			return EINVAL;
-		if (!bpf_validate(ptr, fp->fr_dsize/sizeof(struct bpf_insn))) {
-			if (makecopy && fp->fr_data != NULL) {
-				KFREES(fp->fr_data, fp->fr_dsize);
-			}
-			return EINVAL;
-		}
+		if (!bpf_validate(ptr, fp->fr_dsize/sizeof(struct bpf_insn)))
+			goto exit_INVAL_free;
 		break;
 #endif
 	case FR_T_IPF :
 		if (fp->fr_dsize != sizeof(fripf_t))
-			return EINVAL;
+			goto exit_INVAL_free;
 
 		/*
 		 * Allowing a rule with both "keep state" and "with oow" is
@@ -4356,7 +4327,7 @@
 		 * fail with the out of window (oow) flag set.
 		 */
 		if ((fp->fr_flags & FR_KEEPSTATE) && (fp->fr_flx & FI_OOW))
-			return EINVAL;
+			goto exit_INVAL_free;
 
 		switch (fp->fr_satype)
 		{
@@ -4365,12 +4336,8 @@
 		case FRI_NETWORK :
 		case FRI_NETMASKED :
 		case FRI_PEERADDR :
-			if (fp->fr_sifpidx < 0 || fp->fr_sifpidx > 3) {
-				if (makecopy && fp->fr_data != NULL) {
-					KFREES(fp->fr_data, fp->fr_dsize);
-				}
-				return EINVAL;
-			}
+			if (fp->fr_sifpidx < 0 || fp->fr_sifpidx > 3)
+				goto exit_INVAL_free;
 			break;
 #ifdef	IPFILTER_LOOKUP
 		case FRI_LOOKUP :
@@ -4378,8 +4345,10 @@
 							 fp->fr_srcsubtype,
 							 &fp->fr_slookup,
 							 &fp->fr_srcfunc);
-			if (fp->fr_srcptr == NULL)
-				return ESRCH;
+			if (fp->fr_srcptr == NULL) {
+				error = ESRCH;
+				goto exit_free;
+			}
 			break;
 #endif
 		default :
@@ -4393,12 +4362,8 @@
 		case FRI_NETWORK :
 		case FRI_NETMASKED :
 		case FRI_PEERADDR :
-			if (fp->fr_difpidx < 0 || fp->fr_difpidx > 3) {
-				if (makecopy && fp->fr_data != NULL) {
-					KFREES(fp->fr_data, fp->fr_dsize);
-				}
-				return EINVAL;
-			}
+			if (fp->fr_difpidx < 0 || fp->fr_difpidx > 3)
+				goto exit_INVAL_free;
 			break;
 #ifdef	IPFILTER_LOOKUP
 		case FRI_LOOKUP :
@@ -4406,8 +4371,10 @@
 							 fp->fr_dstsubtype,
 							 &fp->fr_dlookup,
 							 &fp->fr_dstfunc);
-			if (fp->fr_dstptr == NULL)
-				return ESRCH;
+			if (fp->fr_dstptr == NULL) {
+				error = ESRCH;
+				goto exit_free;
+			}
 			break;
 #endif
 		default :
@@ -4415,16 +4382,19 @@
 		}
 		break;
 	case FR_T_NONE :
-		break;
 	case FR_T_CALLFUNC :
-		break;
 	case FR_T_COMPIPF :
 		break;
 	default :
+exit_INVAL_free:
+		error = EINVAL;
+#ifdef IPFILTER_LOOKUP
+exit_free:
+#endif
 		if (makecopy && fp->fr_data != NULL) {
 			KFREES(fp->fr_data, fp->fr_dsize);
 		}
-		return EINVAL;
+		return error;
 	}
 
 	/*
@@ -4514,11 +4484,8 @@
 			}
 		}
 
-		if ((ptr != NULL) && (makecopy != 0)) {
-			KFREES(ptr, fp->fr_dsize);
-		}
-		RWLOCK_EXIT(&ipf_mutex);
-		return error;
+		need_free = 1;
+		goto done;
 	}
 
 	if (!f) {
@@ -4539,7 +4506,6 @@
 			}
 			f = NULL;
 			ptr = NULL;
-			error = 0;
 		} else if (req == (ioctlcmd_t)SIOCINAFR ||
 			   req == (ioctlcmd_t)SIOCINIFR) {
 			while ((f = *fprev) != NULL) {
@@ -4559,7 +4525,6 @@
 			}
 			f = NULL;
 			ptr = NULL;
-			error = 0;
 		}
 	}
 
@@ -4592,6 +4557,7 @@
 			    (f->fr_isc != (struct ipscan *)-1))
 				ipsc_detachfr(f);
 #endif
+			need_free = 1;
 			if (unit == IPL_LOGAUTH) {
 				error = fr_preauthcmd(req, f, ftail);
 				goto done;
@@ -4651,8 +4617,18 @@
 	}
 done:
 	RWLOCK_EXIT(&ipf_mutex);
-	if ((ptr != NULL) && (error != 0) && (makecopy != 0)) {
-		KFREES(ptr, fp->fr_dsize);
+	if (error != 0 || need_free != 0) {
+		if ((ptr != NULL) && (makecopy != 0)) {
+			KFREES(ptr, fp->fr_dsize);
+		}
+#ifdef IPFILTER_LOOKUP
+		if ((fp->fr_type & ~FR_T_BUILTIN) == FR_T_IPF) {
+			if (fp->fr_satype == FRI_LOOKUP)
+				ip_lookup_deref(fp->fr_srctype, fp->fr_srcptr);
+			if (fp->fr_datype == FRI_LOOKUP)
+				ip_lookup_deref(fp->fr_dsttype, fp->fr_dstptr);
+		}
+#endif
 	}
 	return (error);
 }
@@ -4825,9 +4801,11 @@
 		MUTEX_DESTROY(&fr->fr_lock);
 
 #ifdef IPFILTER_LOOKUP
-		if (fr->fr_type == FR_T_IPF && fr->fr_satype == FRI_LOOKUP)
+		if ((fr->fr_type & ~FR_T_BUILTIN) == FR_T_IPF &&
+		    fr->fr_satype == FRI_LOOKUP)
 			ip_lookup_deref(fr->fr_srctype, fr->fr_srcptr);
-		if (fr->fr_type == FR_T_IPF && fr->fr_datype == FRI_LOOKUP)
+		if ((fr->fr_type & ~FR_T_BUILTIN) == FR_T_IPF &&
+		    fr->fr_datype == FRI_LOOKUP)
 			ip_lookup_deref(fr->fr_dsttype, fr->fr_dstptr);
 #endif
 
@@ -5222,48 +5200,70 @@
 ipftqent_t *tqe;
 ipftq_t *oifq, *nifq;
 {
+
 	/*
-	 * Is the operation here going to be a no-op ?
+	 * If the queue hasn't changed and we last touched this entry at the
+	 * same ipf time, then we're not going to achieve anything by either
+	 * changing the ttl or moving it on the queue.
+	 */
+	if (oifq == nifq && tqe->tqe_touched == fr_ticks)
+		return;
+
+	/*
+	 * For any of this to be outside the lock, there is a risk that two
+	 * packets entering simultaneously, with one changing to a different
+	 * queue and one not, could end up with things in a bizarre state.
 	 */
 	MUTEX_ENTER(&oifq->ifq_lock);
-	if ((oifq != nifq) || (*oifq->ifq_tail != tqe)) {
-		/*
-		 * Remove from the old queue
-		 */
-		*tqe->tqe_pnext = tqe->tqe_next;
-		if (tqe->tqe_next)
-			tqe->tqe_next->tqe_pnext = tqe->tqe_pnext;
-		else
-			oifq->ifq_tail = tqe->tqe_pnext;
-		tqe->tqe_next = NULL;
 
-		/*
-		 * If we're moving from one queue to another, release the
-		 * lock on the old queue and get a lock on the new queue.
-		 * For user defined queues, if we're moving off it, call
-		 * delete in case it can now be freed.
-		 */
-		if (oifq != nifq) {
-			tqe->tqe_ifq = NULL;
+	tqe->tqe_touched = fr_ticks;
+	tqe->tqe_die = fr_ticks + nifq->ifq_ttl;
+	/*
+	 * Is the operation here going to be a no-op ?
+	 */
+	if (oifq == nifq) {
+		if ((tqe->tqe_next == NULL) ||
+		    (tqe->tqe_next->tqe_die == tqe->tqe_die)) {
+			MUTEX_EXIT(&oifq->ifq_lock);
+			return;
+		}
+	}
 
-			(void) fr_deletetimeoutqueue(oifq);
+	/*
+	 * Remove from the old queue
+	 */
+	*tqe->tqe_pnext = tqe->tqe_next;
+	if (tqe->tqe_next)
+		tqe->tqe_next->tqe_pnext = tqe->tqe_pnext;
+	else
+		oifq->ifq_tail = tqe->tqe_pnext;
+	tqe->tqe_next = NULL;
 
-			MUTEX_EXIT(&oifq->ifq_lock);
+	/*
+	 * If we're moving from one queue to another, release the
+	 * lock on the old queue and get a lock on the new queue.
+	 * For user defined queues, if we're moving off it, call
+	 * delete in case it can now be freed.
+	 */
+	if (oifq != nifq) {
+		tqe->tqe_ifq = NULL;
 
-			MUTEX_ENTER(&nifq->ifq_lock);
+		(void) fr_deletetimeoutqueue(oifq);
 
-			tqe->tqe_ifq = nifq;
-			nifq->ifq_ref++;
-		}
+		MUTEX_EXIT(&oifq->ifq_lock);
 
-		/*
-		 * Add to the bottom of the new queue
-		 */
-		tqe->tqe_die = fr_ticks + nifq->ifq_ttl;
-		tqe->tqe_pnext = nifq->ifq_tail;
-		*nifq->ifq_tail = tqe;
-		nifq->ifq_tail = &tqe->tqe_next;
+		MUTEX_ENTER(&nifq->ifq_lock);
+
+		tqe->tqe_ifq = nifq;
+		nifq->ifq_ref++;
 	}
+
+	/*
+	 * Add to the bottom of the new queue
+	 */
+	tqe->tqe_pnext = nifq->ifq_tail;
+	*nifq->ifq_tail = tqe;
+	nifq->ifq_tail = &tqe->tqe_next;
 	MUTEX_EXIT(&nifq->ifq_lock);
 }
 
@@ -5443,28 +5443,32 @@
 
 /*
  * This array defines the expected size of objects coming into the kernel
- * for the various recognised object types.
+ * for the various recognised object types. The first column is flags (see
+ * below), 2nd column is current size, 3rd column is the version number of
+ * when the current size became current.
+ * Flags:
+ * 1 = minimum size, not absolute size
  */
-static	int	fr_objbytes[IPFOBJ_COUNT][2] = {
-	{ 1,	sizeof(struct frentry) },		/* frentry */
-	{ 0,	sizeof(struct friostat) },
-	{ 0,	sizeof(struct fr_info) },
-	{ 0,	sizeof(struct fr_authstat) },
-	{ 0,	sizeof(struct ipfrstat) },
-	{ 0,	sizeof(struct ipnat) },
-	{ 0,	sizeof(struct natstat) },
-	{ 0,	sizeof(struct ipstate_save) },
-	{ 1,	sizeof(struct nat_save) },		/* nat_save */
-	{ 0,	sizeof(struct natlookup) },
-	{ 1,	sizeof(struct ipstate) },		/* ipstate */
-	{ 0,	sizeof(struct ips_stat) },
-	{ 0,	sizeof(struct frauth) },
-	{ 0,	sizeof(struct ipftune) },
-	{ 0,	sizeof(struct nat) },			/* nat_t */
-	{ 0,	sizeof(struct ipfruleiter) },
-	{ 0,	sizeof(struct ipfgeniter) },
-	{ 0,	sizeof(struct ipftable) },
-	{ 0,	sizeof(struct ipflookupiter) },
+static	int	fr_objbytes[IPFOBJ_COUNT][3] = {
+	{ 1,	sizeof(struct frentry),		4013400 },
+	{ 0,	sizeof(struct friostat),	4013300 },
+	{ 0,	sizeof(struct fr_info),		4013200 },
+	{ 0,	sizeof(struct fr_authstat),	4010100 },
+	{ 0,	sizeof(struct ipfrstat),	4010100 },
+	{ 0,	sizeof(struct ipnat),		4011400 },
+	{ 0,	sizeof(struct natstat),		4013200 },
+	{ 0,	sizeof(struct ipstate_save),	4013400 },
+	{ 1,	sizeof(struct nat_save),	4013400 },
+	{ 0,	sizeof(struct natlookup),	4010100 },
+	{ 1,	sizeof(struct ipstate),		4011600 },
+	{ 0,	sizeof(struct ips_stat),	4012100 },
+	{ 0,	sizeof(struct frauth),		4013200 },
+	{ 0,	sizeof(struct ipftune),		4010100 },
+	{ 0,	sizeof(struct nat),		4012500 },	/* nat_t */
+	{ 0,	sizeof(struct ipfruleiter),	4011400 },	/* Added. */
+	{ 0,	sizeof(struct ipfgeniter),	4011400 },	/* Added. */
+	{ 0,	sizeof(struct ipftable),	4011400 },	/* Added. */
+	{ 0,	sizeof(struct ipflookupiter),	4011400 },	/* Added. */
 	{ 0,	sizeof(struct ipftq) * IPF_TCP_NSTATES },
 };
 
@@ -5473,56 +5477,59 @@
 /* Function:    fr_inobj                                                    */
 /* Returns:     int     - 0 = success, else failure                         */
 /* Parameters:  data(I) - pointer to ioctl data                             */
+/*              objp(O) - where to store ipfobj_t data                      */
 /*              ptr(I)  - pointer to store real data in                     */
 /*              type(I) - type of structure being moved                     */
 /*                                                                          */
 /* Copy in the contents of what the ipfobj_t points to.  In future, we      */
 /* add things to check for version numbers, sizes, etc, to make it backward */
 /* compatible at the ABI for user land.                                     */
+/* Provision of objp is supported to provide the means by which the version */
+/* number from the incoming request can be returned and then used when      */
+/* copying out data. This is essential for IPFILTER_COMPAT when dealing     */
+/* programs compiled against older header files.                            */
 /* ------------------------------------------------------------------------ */
-int fr_inobj(data, ptr, type)
+int fr_inobj(data, objp, ptr, type)
 void *data;
+ipfobj_t *objp;
 void *ptr;
 int type;
 {
 	ipfobj_t obj;
 	int error = 0;
+	int size;
 
 	if ((type < 0) || (type >= IPFOBJ_COUNT))
 		return EINVAL;
 
-	error = BCOPYIN(data, &obj, sizeof(obj));
+	if (objp == NULL)
+		objp = &obj;
+	error = BCOPYIN(data, objp, sizeof(*objp));
 	if (error != 0)
 		return EFAULT;
 
-	if (obj.ipfo_type != type)
+	if (objp->ipfo_type != type)
 		return EINVAL;
 
-#ifndef	IPFILTER_COMPAT
-	if ((fr_objbytes[type][0] & 1) != 0) {
-		if (obj.ipfo_size < fr_objbytes[type][1])
+	if (objp->ipfo_rev >= fr_objbytes[type][2]) {
+		if ((fr_objbytes[type][0] & 1) != 0) {
+			if (objp->ipfo_size < fr_objbytes[type][1])
+				return EINVAL;
+			size =  fr_objbytes[type][1];
+		} else if (objp->ipfo_size == fr_objbytes[type][1]) {
+			size =  objp->ipfo_size;
+		} else {
 			return EINVAL;
-	} else if (obj.ipfo_size != fr_objbytes[type][1]) {
-		return EINVAL;
-	}
+		}
+		error = COPYIN(objp->ipfo_ptr, ptr, size);
+	} else {
+#ifdef	IPFILTER_COMPAT
+		error = fr_in_compat(objp, ptr);
 #else
-	if (obj.ipfo_rev != IPFILTER_VERSION)
-		/* XXX compatibility hook here */
-		;
-	if ((fr_objbytes[type][0] & 1) != 0) {
-		if (obj.ipfo_size < fr_objbytes[type][1])
-			/* XXX compatibility hook here */
-			return EINVAL;
-	} else if (obj.ipfo_size != fr_objbytes[type][1])
-		/* XXX compatibility hook here */
 		return EINVAL;
 #endif
-
-	if ((fr_objbytes[type][0] & 1) != 0) {
-		error = COPYIN(obj.ipfo_ptr, ptr, fr_objbytes[type][1]);
-	} else {
-		error = COPYIN(obj.ipfo_ptr, ptr, obj.ipfo_size);
 	}
+
 	if (error != 0)
 		error = EFAULT;
 	return error;
@@ -5553,8 +5560,6 @@
 
 	if ((type < 0) || (type >= IPFOBJ_COUNT))
 		return EINVAL;
-	if (((fr_objbytes[type][0] & 1) == 0) || (sz < fr_objbytes[type][1]))
-		return EINVAL;
 
 	error = BCOPYIN(data, &obj, sizeof(obj));
 	if (error != 0)
@@ -5563,19 +5568,20 @@
 	if (obj.ipfo_type != type)
 		return EINVAL;
 
-#ifndef	IPFILTER_COMPAT
-	if (obj.ipfo_size != sz)
-		return EINVAL;
+	if (obj.ipfo_rev >= fr_objbytes[type][2]) {
+		if (((fr_objbytes[type][0] & 1) == 0) ||
+		    (sz < fr_objbytes[type][1]))
+			return EINVAL;
+
+		error = COPYIN(obj.ipfo_ptr, ptr, sz);
+	} else {
+#ifdef	IPFILTER_COMPAT
+		error = fr_in_compat(&obj, ptr);
 #else
-	if (obj.ipfo_rev != IPFILTER_VERSION)
-		/* XXX compatibility hook here */
-		;
-	if (obj.ipfo_size != sz)
-		/* XXX compatibility hook here */
-		return EINVAL;
+		error = EINVAL;
 #endif
+	}
 
-	error = COPYIN(obj.ipfo_ptr, ptr, sz);
 	if (error != 0)
 		error = EFAULT;
 	return error;
@@ -5604,9 +5610,7 @@
 	ipfobj_t obj;
 	int error;
 
-	if ((type < 0) || (type >= IPFOBJ_COUNT) ||
-	    ((fr_objbytes[type][0] & 1) == 0) ||
-	    (sz < fr_objbytes[type][1]))
+	if ((type < 0) || (type >= IPFOBJ_COUNT))
 		return EINVAL;
 
 	error = BCOPYIN(data, &obj, sizeof(obj));
@@ -5616,19 +5620,20 @@
 	if (obj.ipfo_type != type)
 		return EINVAL;
 
-#ifndef	IPFILTER_COMPAT
-	if (obj.ipfo_size != sz)
-		return EINVAL;
+	if (obj.ipfo_rev >= fr_objbytes[type][2]) {
+		if (((fr_objbytes[type][0] & 1) == 0) ||
+		    (sz < fr_objbytes[type][1]))
+			return EINVAL;
+
+		error = COPYOUT(ptr, obj.ipfo_ptr, sz);
+	} else {
+#ifdef	IPFILTER_COMPAT
+		error = fr_out_compat(&obj, ptr);
 #else
-	if (obj.ipfo_rev != IPFILTER_VERSION)
-		/* XXX compatibility hook here */
-		;
-	if (obj.ipfo_size != sz)
-		/* XXX compatibility hook here */
 		return EINVAL;
 #endif
+	}
 
-	error = COPYOUT(ptr, obj.ipfo_ptr, sz);
 	if (error != 0)
 		error = EFAULT;
 	return error;
@@ -5639,7 +5644,7 @@
 /* Function:    fr_outobj                                                   */
 /* Returns:     int     - 0 = success, else failure                         */
 /* Parameters:  data(I) - pointer to ioctl data                             */
-/*              ptr(I)  - pointer to store real data in                     */
+/*              ptr(I)  - pointer to data to copy out                       */
 /*              type(I) - type of structure being moved                     */
 /*                                                                          */
 /* Copy out the contents of what ptr is to where ipfobj points to.  In      */
@@ -5664,28 +5669,70 @@
 	if (obj.ipfo_type != type)
 		return EINVAL;
 
-#ifndef	IPFILTER_COMPAT
-	if ((fr_objbytes[type][0] & 1) != 0) {
-		if (obj.ipfo_size < fr_objbytes[type][1])
+	if (obj.ipfo_rev >= fr_objbytes[type][2]) {
+		if ((fr_objbytes[type][0] & 1) != 0) {
+			if (obj.ipfo_size < fr_objbytes[type][1])
+				return EINVAL;
+		} else if (obj.ipfo_size != fr_objbytes[type][1]) {
 			return EINVAL;
-	} else if (obj.ipfo_size != fr_objbytes[type][1])
-		return EINVAL;
+		}
+
+		error = COPYOUT(ptr, obj.ipfo_ptr, obj.ipfo_size);
+		if (error != 0)
+			error = EFAULT;
+	} else {
+#ifdef	IPFILTER_COMPAT
+		error = fr_out_compat(&obj, ptr);
 #else
-	if (obj.ipfo_rev != IPFILTER_VERSION)
-		/* XXX compatibility hook here */
-		;
-	if ((fr_objbytes[type][0] & 1) != 0) {
-		if (obj.ipfo_size < fr_objbytes[type][1])
-			/* XXX compatibility hook here */
-			return EINVAL;
-	} else if (obj.ipfo_size != fr_objbytes[type][1])
-		/* XXX compatibility hook here */
-		return EINVAL;
+		error = EINVAL;
 #endif
+	}
+	return error;
+}
 
-	error = COPYOUT(ptr, obj.ipfo_ptr, obj.ipfo_size);
-	if (error != 0)
-		error = EFAULT;
+
+/* ------------------------------------------------------------------------ */
+/* Function:    fr_outobjk                                                  */
+/* Returns:     int     - 0 = success, else failure                         */
+/* Parameters:  obj(I)  - pointer to data description structure             */
+/*              ptr(I)  - pointer to kernel data to copy out                */
+/*                                                                          */
+/* In the above functions, the ipfobj_t structure is copied into the kernel,*/
+/* telling ipfilter how to copy out data. In this instance, the ipfobj_t is */
+/* already populated with information and now we just need to use it.       */
+/* There is no need for this function to have a "type" parameter as there   */
+/* is no point in validating information that comes from the kernel with    */
+/* itself.                                                                  */
+/* ------------------------------------------------------------------------ */
+int fr_outobjk(obj, ptr)
+ipfobj_t *obj;
+void *ptr;
+{
+	int type = obj->ipfo_type;
+	int error;
+
+	if ((type < 0) || (type >= IPFOBJ_COUNT))
+		return EINVAL;
+
+	if (obj->ipfo_rev >= fr_objbytes[type][2]) {
+		if ((fr_objbytes[type][0] & 1) != 0) {
+			if (obj->ipfo_size < fr_objbytes[type][1])
+				return EINVAL;
+
+		} else if (obj->ipfo_size != fr_objbytes[type][1]) {
+			return EINVAL;
+		}
+
+		error = COPYOUT(ptr, obj->ipfo_ptr, obj->ipfo_size);
+		if (error != 0)
+			error = EFAULT;
+	} else {
+#ifdef	IPFILTER_COMPAT
+		error = fr_out_compat(obj, ptr);
+#else
+		error = EINVAL;
+#endif
+	}
 	return error;
 }
 
@@ -5998,6 +6045,8 @@
 		sizeof(fr_tcpclosed),		IPFT_WRDISABLED,	NULL },
 	{ { &fr_tcphalfclosed }, "fr_tcphalfclosed",	1,	0x7fffffff,
 		sizeof(fr_tcphalfclosed),	IPFT_WRDISABLED,	NULL },
+	{ { &fr_tcptimewait }, "fr_tcptimewait",	1,	0x7fffffff,
+		sizeof(fr_tcptimewait),		IPFT_WRDISABLED,	NULL },
 	{ { &fr_udptimeout },	"fr_udptimeout",	1,	0x7fffffff,
 		sizeof(fr_udptimeout),		IPFT_WRDISABLED,	NULL },
 	{ { &fr_udpacktimeout }, "fr_udpacktimeout",	1,	0x7fffffff,
@@ -6225,7 +6274,7 @@
 	void *cookie;
 	int error;
 
-	error = fr_inobj(data, &tu, IPFOBJ_TUNEABLE);
+	error = fr_inobj(data, NULL, &tu, IPFOBJ_TUNEABLE);
 	if (error != 0)
 		return error;
 
@@ -6480,12 +6529,16 @@
 void	*data;
 {
 	friostat_t fio;
+	ipfobj_t obj;
 	int error;
 
-	fr_getstat(&fio);
+	error = fr_inobj(data, &obj, &fio, IPFOBJ_IPFSTAT);
+	if (error)
+		return error;
+	fr_getstat(&fio, obj.ipfo_rev);
 	error = fr_outobj(data, &fio, IPFOBJ_IPFSTAT);
 	if (error)
-		return EFAULT;
+		return error;
 
 	WRITE_ENTER(&ipf_mutex);
 	bzero(&frstats, sizeof(frstats));
@@ -6652,8 +6705,6 @@
 
 	WRITE_ENTER(&ipf_tokens);
 	for (it = ipftokenhead; it != NULL; it = it->ipt_next) {
-		if (it->ipt_alive == 0)
-			continue;
 		if (ptr == it->ipt_ctx && type == it->ipt_type &&
 		    uid == it->ipt_uid)
 			break;
@@ -6669,7 +6720,7 @@
 		it->ipt_uid = uid;
 		it->ipt_type = type;
 		it->ipt_next = NULL;
-		it->ipt_alive = 1;
+		it->ipt_ref = 2;
 	} else {
 		if (new != NULL) {
 			KFREE(new);
@@ -6677,6 +6728,7 @@
 		}
 
 		ipf_unlinktoken(it);
+		it->ipt_ref++;
 	}
 	it->ipt_pnext = ipftokentail;
 	*ipftokentail = it;
@@ -6685,7 +6737,7 @@
 
 	it->ipt_die = fr_ticks + 2;
 
-	MUTEX_DOWNGRADE(&ipf_tokens);
+	RWLOCK_EXIT(&ipf_tokens);
 
 	return it;
 }
@@ -6695,6 +6747,7 @@
 /* Function:    ipf_unlinktoken                                             */
 /* Returns:     None.                                                       */
 /* Parameters:  token(I) - pointer to token structure                       */
+/* Write Locks: ipf_tokens                                                  */
 /*                                                                          */
 /* This function unlinks a token structure from the linked list of tokens   */
 /* that "own" it.  The head pointer never needs to be explicitly adjusted   */
@@ -6713,22 +6766,25 @@
 }
 
 
+
 /* ------------------------------------------------------------------------ */
-/* Function:    ipf_freetoken                                               */
+/* Function:    ipf_dereftoken                                              */
 /* Returns:     None.                                                       */
 /* Parameters:  token(I) - pointer to token structure                       */
+/* Write Locks: ipf_tokens                                                  */
 /*                                                                          */
-/* This function unlinks a token from the linked list and on the path to    */
-/* free'ing the data, it calls the dereference function that is associated  */
-/* with the type of data pointed to by the token as it is considered to     */
-/* hold a reference to it.                                                  */
+/* Drop the reference count on the token structure and if it drops to zero, */
+/* call the dereference function for the token type because it is then      */
+/* possible to free the token data structure.                               */
 /* ------------------------------------------------------------------------ */
-void ipf_freetoken(token)
+void ipf_dereftoken(token)
 ipftoken_t *token;
 {
 	void *data, **datap;
 
-	ipf_unlinktoken(token);
+	token->ipt_ref--;
+	if (token->ipt_ref > 0)
+		return;
 
 	data = token->ipt_data;
 	datap = &data;
@@ -6782,6 +6838,25 @@
 
 
 /* ------------------------------------------------------------------------ */
+/* Function:    ipf_freetoken                                               */
+/* Returns:     None.                                                       */
+/* Parameters:  token(I) - pointer to token structure                       */
+/* Write Locks: ipf_tokens                                                  */
+/*                                                                          */
+/* This function unlinks a token from the linked list and does a dereference*/
+/* on it to encourage it to be freed.                                       */
+/* ------------------------------------------------------------------------ */
+void ipf_freetoken(token)
+ipftoken_t *token;
+{
+
+	ipf_unlinktoken(token);
+
+	ipf_dereftoken(token);
+}
+
+
+/* ------------------------------------------------------------------------ */
 /* Function:    ipf_getnextrule                                             */
 /* Returns:     int - 0 = success, else error                               */
 /* Parameters:  t(I)   - pointer to destination information to resolve      */
@@ -6801,11 +6876,12 @@
 	int error, count, out;
 	ipfruleiter_t it;
 	frgroup_t *fg;
+	ipfobj_t obj;
 	char *dst;
 
 	if (t == NULL || ptr == NULL)
 		return EFAULT;
-	error = fr_inobj(ptr, &it, IPFOBJ_IPFITER);
+	error = fr_inobj(ptr, &obj, &it, IPFOBJ_IPFITER);
 	if (error != 0)
 		return error;
 	if ((it.iri_inout < 0) || (it.iri_inout > 3))
@@ -6818,8 +6894,12 @@
 		return EFAULT;
 
 	out = it.iri_inout & F_OUT;
-	fr = t->ipt_data;
 	READ_ENTER(&ipf_mutex);
+
+	/*
+	 * Retrieve "previous" entry from token and find the next entry.
+	 */
+	fr = t->ipt_data;
 	if (fr == NULL) {
 		if (*it.iri_group == '\0') {
 			if ((it.iri_inout & F_ACIN) != 0) {
@@ -6845,54 +6925,69 @@
 		next = fr->fr_next;
 	}
 
+	obj.ipfo_type = IPFOBJ_FRENTRY;
+	obj.ipfo_size = 0;
 	dst = (char *)it.iri_rule;
-	count = it.iri_nrules;
 	/*
 	 * The ipfruleiter may ask for more than 1 rule at a time to be
 	 * copied out, so long as that many exist in the list to start with!
 	 */
-	for (;;) {
+	for (count = it.iri_nrules; count > 0; count--) {
+		/*
+		 * If we found an entry, add reference to it and update token.
+		 * Otherwise, zero out data to be returned and NULL out token.
+		 */
 		if (next != NULL) {
-			if (count == 1) {
-				MUTEX_ENTER(&next->fr_lock);
-				next->fr_ref++;
-				MUTEX_EXIT(&next->fr_lock);
-				t->ipt_data = next;
-			}
+			MUTEX_ENTER(&next->fr_lock);
+			next->fr_ref++;
+			MUTEX_EXIT(&next->fr_lock);
+			t->ipt_data = next;
 		} else {
 			bzero(&zero, sizeof(zero));
 			next = &zero;
-			count = 1;
 			t->ipt_data = NULL;
 		}
+
+		/*
+		 * Now that we have ref, it's save to give up lock.
+		 */
 		RWLOCK_EXIT(&ipf_mutex);
 
-		error = COPYOUT(next, dst, sizeof(*next));
+		/*
+		 * Copy out data and clean up references and token as needed.
+		 */
+		obj.ipfo_size = sizeof(frentry_t);
+		obj.ipfo_ptr = dst;
+		error = fr_outobjk(&obj, next);
 		if (error != 0)
 			return EFAULT;
-
-		if (next->fr_data != NULL) {
-			dst += sizeof(*next);
-			error = COPYOUT(next->fr_data, dst, next->fr_dsize);
-			if (error != 0)
-				error = EFAULT;
-			else
-				dst += next->fr_dsize;
+		if (t->ipt_data == NULL) {
+			break;
+		} else {
+			if (fr != NULL)
+				(void) fr_derefrule(&fr);
+			if (next->fr_data != NULL) {
+				dst += obj.ipfo_size;
+				error = COPYOUT(next->fr_data, dst,
+						next->fr_dsize);
+				if (error != 0)
+					error = EFAULT;
+				else
+					dst += next->fr_dsize;
+			}
+			if (next->fr_next == NULL) {
+				ipf_freetoken(t);
+				break;
+			}
 		}
 
 		if ((count == 1) || (error != 0))
 			break;
 
-		count--;
-
 		READ_ENTER(&ipf_mutex);
+		fr = next;
 		next = next->fr_next;
 	}
-
-	if (fr != NULL) {
-		(void) fr_derefrule(&fr);
-	}
-
 	return error;
 }
 
@@ -6916,11 +7011,17 @@
 	int error;
 
 	token = ipf_findtoken(IPFGENITER_IPF, uid, ctx);
-	if (token != NULL)
+	if (token != NULL) {
 		error = ipf_getnextrule(token, data);
-	else
+		WRITE_ENTER(&ipf_tokens);
+		if (token->ipt_data == NULL)
+			ipf_freetoken(token);
+		else
+			ipf_dereftoken(token);
+		RWLOCK_EXIT(&ipf_tokens);
+	} else {
 		error = EFAULT;
-	RWLOCK_EXIT(&ipf_tokens);
+	}
 
 	return error;
 }
@@ -6974,7 +7075,7 @@
 	ipfgeniter_t iter;
 	int error;
 
-	error = fr_inobj(data, &iter, IPFOBJ_GENITER);
+	error = fr_inobj(data, NULL, &iter, IPFOBJ_GENITER);
 	if (error != 0)
 		return error;
 
@@ -6982,6 +7083,12 @@
 	if (token != NULL) {
 		token->ipt_subtype = iter.igi_type;
 		error = ipf_geniter(token, &iter);
+		WRITE_ENTER(&ipf_tokens);
+		if (token->ipt_data == NULL)
+			ipf_freetoken(token);
+		else
+			ipf_dereftoken(token);
+		RWLOCK_EXIT(&ipf_tokens);
 	} else
 		error = EFAULT;
 	RWLOCK_EXIT(&ipf_tokens);
@@ -7010,6 +7117,7 @@
 {
 	friostat_t fio;
 	int error, tmp;
+	ipfobj_t obj;
 	SPL_INT(s);
 
 	switch (cmd)
@@ -7110,7 +7218,10 @@
 		break;
 
 	case SIOCGETFS :
-		fr_getstat(&fio);
+		error = fr_inobj((void *)data, &obj, &fio, IPFOBJ_IPFSTAT);
+		if (error != 0)
+			break;
+		fr_getstat(&fio, obj.ipfo_rev);
 		error = fr_outobj((void *)data, &fio, IPFOBJ_IPFSTAT);
 		break;
 
@@ -7312,7 +7423,7 @@
 	for (;;) {
 		u_long try;
 
-		try = fr_ticks - istart; 
+		try = fr_ticks - istart;
 
 		for (ifq = ipfqs; ifq != NULL; ifq = ifq->ifq_next) {
 			for (tqn = ifq->ifq_head; ((tqe = tqn) != NULL); ) {
diff -ur sys.orig/contrib/ipfilter/netinet/ip_auth.c sys/contrib/ipfilter/netinet/ip_auth.c
--- sys.orig/contrib/ipfilter/netinet/ip_auth.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_auth.c	2011-04-27 13:03:01.000000000 +0200
@@ -52,7 +52,7 @@
 # include <sys/stream.h>
 # include <sys/kmem.h>
 #endif
-#if (defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802) || \
+#if (defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802)) || \
     (defined(__FreeBSD_version) &&(__FreeBSD_version >= 400000))
 # include <sys/queue.h>
 #endif
@@ -66,7 +66,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -135,6 +133,7 @@
 
 int	fr_authsize = FR_NUMAUTH;
 int	fr_authused = 0;
+int	fr_authreplies = 0;
 int	fr_defaultauthage = 600;
 int	fr_auth_lock = 0;
 int	fr_auth_init = 0;
@@ -147,7 +146,7 @@
 		*fr_authlist = NULL;
 
 void fr_authderef __P((frauthent_t **));
-int fr_authgeniter __P((ipftoken_t *, ipfgeniter_t *));
+int fr_authgeniter __P((ipftoken_t *, ipfgeniter_t *, ipfobj_t *));
 int fr_authreply __P((char *));
 int fr_authwait __P((char *));
 
@@ -253,6 +252,7 @@
 			} else
 				fr = fra->fra_info.fin_fr;
 			fin->fin_fr = fr;
+			fin->fin_flx |= fra->fra_flx;
 			RWLOCK_EXIT(&ipf_auth);
 
 			WRITE_ENTER(&ipf_auth);
@@ -267,6 +267,7 @@
 			fr_authstats.fas_hits++;
 			fra->fra_index = -1;
 			fr_authused--;
+			fr_authreplies--;
 			if (i == fr_authstart) {
 				while (fra->fra_index == -1) {
 					i++;
@@ -281,7 +282,8 @@
 				}
 				if (fr_authstart == fr_authend) {
 					fr_authnext = 0;
-					fr_authstart = fr_authend = 0;
+					fr_authstart = 0;
+					fr_authend = 0;
 				}
 			}
 			RWLOCK_EXIT(&ipf_auth);
@@ -339,16 +341,17 @@
 	i = fr_authend++;
 	if (fr_authend == fr_authsize)
 		fr_authend = 0;
+
 	fra = fr_auth + i;
 	fra->fra_index = i;
-	RWLOCK_EXIT(&ipf_auth);
-
 	if (fin->fin_fr != NULL)
 		fra->fra_pass = fin->fin_fr->fr_flags;
 	else
 		fra->fra_pass = 0;
 	fra->fra_age = fr_defaultauthage;
 	bcopy((char *)fin, (char *)&fra->fra_info, sizeof(*fin));
+	fra->fra_flx = fra->fra_info.fin_flx & (FI_STATE|FI_NATED);
+	fra->fra_info.fin_flx &= ~(FI_STATE|FI_NATED);
 #if !defined(sparc) && !defined(m68k)
 	/*
 	 * No need to copyback here as we want to undo the changes, not keep
@@ -370,17 +373,19 @@
 #if SOLARIS && defined(_KERNEL)
 	COPYIFNAME(fin->fin_v, fin->fin_ifp, fra->fra_info.fin_ifname);
 	m->b_rptr -= qpi->qpi_off;
-	fr_authpkts[i] = *(mblk_t **)fin->fin_mp;
 # if !defined(_INET_IP_STACK_H)
 	fra->fra_q = qpi->qpi_q;	/* The queue can disappear! */
 # endif
 	fra->fra_m = *fin->fin_mp;
 	fra->fra_info.fin_mp = &fra->fra_m;
+	fr_authpkts[i] = fra->fra_m;
+	RWLOCK_EXIT(&ipf_auth);
 	cv_signal(&ipfauthwait);
 	pollwakeup(&iplpollhead[IPL_LOGAUTH], POLLIN|POLLRDNORM);
 #else
 	fr_authpkts[i] = m;
-	WAKEUP(&fr_authnext,0);
+	RWLOCK_EXIT(&ipf_auth);
+	WAKEUP(&fr_authnext, 0);
 #endif
 	return 1;
 }
@@ -413,18 +418,25 @@
 	    {
 		ipftoken_t *token;
 		ipfgeniter_t iter;
+		ipfobj_t obj;
 
-		error = fr_inobj(data, &iter, IPFOBJ_GENITER);
+		error = fr_inobj(data, &obj, &iter, IPFOBJ_GENITER);
 		if (error != 0)
 			break;
 
 		SPL_SCHED(s);
 		token = ipf_findtoken(IPFGENITER_AUTH, uid, ctx);
-		if (token != NULL)
-			error = fr_authgeniter(token, &iter);
-		else
+		if (token != NULL) {
+			error = fr_authgeniter(token, &iter, &obj);
+			WRITE_ENTER(&ipf_tokens);
+			if (token->ipt_data == NULL)
+				ipf_freetoken(token);
+			else
+				ipf_dereftoken(token);
+			RWLOCK_EXIT(&ipf_tokens);
+		} else {
 			error = ESRCH;
-		RWLOCK_EXIT(&ipf_tokens);
+		}
 		SPL_X(s);
 
 		break;
@@ -563,9 +575,14 @@
 	WRITE_ENTER(&ipf_auth);
 	for (i = 0, fra = fr_auth; i < fr_authsize; i++, fra++) {
 		fra->fra_age--;
-		if ((fra->fra_age == 0) && (m = fr_authpkts[i])) {
-			FREE_MB_T(m);
-			fr_authpkts[i] = NULL;
+		if ((fra->fra_age == 0) && (fr_auth[i].fra_index != -1)) {
+			if ((m = fr_authpkts[i]) != NULL) {
+				FREE_MB_T(m);
+				fr_authpkts[i] = NULL;
+			} else if (fr_auth[i].fra_index == -2) {
+				fr_authreplies--;
+			}
+
 			fr_auth[i].fra_index = -1;
 			fr_authstats.fas_expire++;
 			fr_authused--;
@@ -690,14 +707,16 @@
 	num_flushed = 0;
 
 	for (i = 0 ; i < fr_authsize; i++) {
-		m = fr_authpkts[i];
-		if (m != NULL) {
-			FREE_MB_T(m);
-			fr_authpkts[i] = NULL;
+		if (fr_auth[i].fra_index != -1) {
+			m = fr_authpkts[i];
+			if (m != NULL) {
+				FREE_MB_T(m);
+				fr_authpkts[i] = NULL;
+			}
+
 			fr_auth[i].fra_index = -1;
 			/* perhaps add & use a flush counter inst.*/
 			fr_authstats.fas_expire++;
-			fr_authused--;
 			num_flushed++;
 		}
 	}
@@ -705,6 +724,8 @@
 	fr_authstart = 0;
 	fr_authend = 0;
 	fr_authnext = 0;
+	fr_authused = 0;
+	fr_authreplies = 0;
 
 	return num_flushed;
 }
@@ -731,9 +752,10 @@
 /*              itp(I)   - pointer to ipfgeniter structure                  */
 /*                                                                          */
 /* ------------------------------------------------------------------------ */
-int fr_authgeniter(token, itp)
+int fr_authgeniter(token, itp, obj)
 ipftoken_t *token;
 ipfgeniter_t *itp;
+ipfobj_t *obj;
 {
 	frauthent_t *fae, *next, zero;
 	int error;
@@ -744,49 +766,59 @@
 	if (itp->igi_type != IPFGENITER_AUTH)
 		return EINVAL;
 
-	fae = token->ipt_data;
+	obj->ipfo_type = IPFOBJ_FRAUTH;
+	obj->ipfo_ptr = itp->igi_data;
+	obj->ipfo_size = sizeof(frauth_t);
+
 	READ_ENTER(&ipf_auth);
+
+	/*
+	 * Retrieve "previous" entry from token and find the next entry.
+	 */
+	fae = token->ipt_data;
 	if (fae == NULL) {
 		next = fae_list;
 	} else {
 		next = fae->fae_next;
 	}
 
+	/*
+	 * If we found an entry, add reference to it and update token.
+	 * Otherwise, zero out data to be returned and NULL out token.
+	 */
 	if (next != NULL) {
-		/*
-		 * If we find an auth entry to use, bump its reference count
-		 * so that it can be used for is_next when we come back.
-		 */
 		ATOMIC_INC(next->fae_ref);
-		if (next->fae_next == NULL) {
-			ipf_freetoken(token);
-			token = NULL;
-		} else {
-			token->ipt_data = next;
-		}
+		token->ipt_data = next;
 	} else {
 		bzero(&zero, sizeof(zero));
 		next = &zero;
+		token->ipt_data = NULL;
 	}
-	RWLOCK_EXIT(&ipf_auth);
 
 	/*
-	 * If we had a prior pointer to an auth entry, release it.
+	 * Safe to release the lock now that we have a reference.
 	 */
-	if (fae != NULL) {
-		WRITE_ENTER(&ipf_auth);
-		fr_authderef(&fae);
-		RWLOCK_EXIT(&ipf_auth);
-	}
+	RWLOCK_EXIT(&ipf_auth);
 
 	/*
-	 * This should arguably be via fr_outobj() so that the auth
-	 * structure can (if required) be massaged going out.
+	 * Copy out the data and clean up references and token as needed.
 	 */
-	error = COPYOUT(next, itp->igi_data, sizeof(*next));
+	error = fr_outobjk(obj, next);
 	if (error != 0)
 		error = EFAULT;
 
+	/*
+	 * Clean up reference and token.
+	 */
+	if (token->ipt_data != NULL) {
+		if (fae != NULL) {
+			WRITE_ENTER(&ipf_auth);
+			fr_authderef(&fae);
+			RWLOCK_EXIT(&ipf_auth);
+		}
+		if (next->fae_next == NULL)
+			token->ipt_data = NULL;
+	}
 	return error;
 }
 
@@ -834,13 +866,10 @@
 	int error, len, i;
 	mb_t *m;
 	char *t;
-#if defined(_KERNEL) && !defined(MENTAT) && !defined(linux) && \
-    (!defined(__FreeBSD_version) || (__FreeBSD_version < 501000))
 	SPL_INT(s);
-#endif
 
 fr_authioctlloop:
-	error = fr_inobj(data, au, IPFOBJ_FRAUTH);
+	error = fr_inobj(data, NULL, au, IPFOBJ_FRAUTH);
 	if (error != 0)
 		return error;
 
@@ -850,6 +879,7 @@
 	 * we are trying to guard against here is an error in the copyout
 	 * steps should not cause the packet to "disappear" from the queue.
 	 */
+	SPL_NET(s);
 	READ_ENTER(&ipf_auth);
 
 	/*
@@ -857,7 +887,7 @@
 	 * is a packet waiting to be delt with in the fr_authpkts array.  We
 	 * copy as much of that out to user space as requested.
 	 */
-	if (fr_authused > 0) {
+	if (fr_authused > fr_authreplies) {
 		while (fr_authpkts[fr_authnext] == NULL) {
 			fr_authnext++;
 			if (fr_authnext == fr_authsize)
@@ -865,8 +895,11 @@
 		}
 
 		error = fr_outobj(data, &fr_auth[fr_authnext], IPFOBJ_FRAUTH);
-		if (error != 0)
+		if (error != 0) {
+			RWLOCK_EXIT(&ipf_auth);
+			SPL_X(s);
 			return error;
+		}
 
 		if (auth.fra_len != 0 && auth.fra_buf != NULL) {
 			/*
@@ -884,8 +917,11 @@
 				error = copyoutptr(MTOD(m, char *), &t, i);
 				len -= i;
 				t += i;
-				if (error != 0)
+				if (error != 0) {
+					RWLOCK_EXIT(&ipf_auth);
+					SPL_X(s);
 					return error;
+				}
 				m = m->m_next;
 			}
 		}
@@ -902,6 +938,7 @@
 		return 0;
 	}
 	RWLOCK_EXIT(&ipf_auth);
+	SPL_X(s);
 
 	MUTEX_ENTER(&ipf_authmx);
 #ifdef	_KERNEL
@@ -949,11 +986,12 @@
 char *data;
 {
 	frauth_t auth, *au = &auth, *fra;
+	fr_info_t fin;
 	int error, i;
 	mb_t *m;
 	SPL_INT(s);
 
-	error = fr_inobj(data, &auth, IPFOBJ_FRAUTH);
+	error = fr_inobj(data, NULL, &auth, IPFOBJ_FRAUTH);
 	if (error != 0)
 		return error;
 
@@ -980,6 +1018,8 @@
 	fra->fra_index = -2;
 	fra->fra_pass = au->fra_pass;
 	fr_authpkts[i] = NULL;
+	fr_authreplies++;
+	bcopy(&fra->fra_info, &fin, sizeof(fin));
 
 	RWLOCK_EXIT(&ipf_auth);
 
@@ -992,7 +1032,7 @@
 	 */
 #ifdef	_KERNEL
 	if ((m != NULL) && (au->fra_info.fin_out != 0)) {
-		error = ipf_inject(&fra->fra_info, m);
+		error = ipf_inject(&fin, m);
 		if (error != 0) {
 			error = ENOBUFS;
 			fr_authstats.fas_sendfail++;
@@ -1000,7 +1040,7 @@
 			fr_authstats.fas_sendok++;
 		}
 	} else if (m) {
-		error = ipf_inject(&fra->fra_info, m);
+		error = ipf_inject(&fin, m);
 		if (error != 0) {
 			error = ENOBUFS;
 			fr_authstats.fas_quefail++;
@@ -1017,21 +1057,33 @@
 	 */
 	if (error == ENOBUFS) {
 		WRITE_ENTER(&ipf_auth);
-		fr_authused--;
-		fra->fra_index = -1;
-		fra->fra_pass = 0;
-		if (i == fr_authstart) {
-			while (fra->fra_index == -1) {
-				i++;
-				if (i == fr_authsize)
-					i = 0;
-				fr_authstart = i;
-				if (i == fr_authend)
-					break;
-			}
-			if (fr_authstart == fr_authend) {
-				fr_authnext = 0;
-				fr_authstart = fr_authend = 0;
+		/*
+		 * Check that the queue item has not been flushed
+		 * (and possible reused) yet.
+		 */
+		if ((fra->fra_index == -2) &&
+		    !bcmp((char *)&fin, (char *)&fra->fra_info, sizeof(fin))) {
+			fr_authused--;
+			fr_authreplies--;
+			fra->fra_index = -1;
+			fra->fra_pass = 0;
+			if (i == fr_authstart) {
+				while (fra->fra_index == -1) {
+					i++;
+					fra++;
+					if (i == fr_authsize) {
+						i = 0;
+						fra = fr_auth;
+					}
+					fr_authstart = i;
+					if (i == fr_authend)
+						break;
+				}
+				if (fr_authstart == fr_authend) {
+					fr_authnext = 0;
+					fr_authstart = 0;
+					fr_authend = 0;
+				}
 			}
 		}
 		RWLOCK_EXIT(&ipf_auth);
diff -ur sys.orig/contrib/ipfilter/netinet/ip_auth.h sys/contrib/ipfilter/netinet/ip_auth.h
--- sys.orig/contrib/ipfilter/netinet/ip_auth.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_auth.h	2011-04-27 13:03:01.000000000 +0200
@@ -21,6 +18,7 @@
 	u_32_t	fra_pass;
 	fr_info_t	fra_info;
 	char	*fra_buf;
+	u_32_t	fra_flx;
 #ifdef	MENTAT
 	queue_t	*fra_q;
 	mb_t	*fra_m;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_compat.h sys/contrib/ipfilter/netinet/ip_compat.h
--- sys.orig/contrib/ipfilter/netinet/ip_compat.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_compat.h	2011-04-27 13:03:01.000000000 +0200
@@ -47,6 +46,9 @@
 #if defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 105000000) && \
     !defined(_KERNEL) && !defined(USE_INET6)
 # define	USE_INET6
+#endif
+#if defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 106140000) && \
+    defined(_KERNEL) && !defined(IPFILTER_LKM)
 # define	IPFILTER_M_IPFILTER
 #endif
 #if defined(OpenBSD) && (OpenBSD >= 200206) && \
@@ -140,7 +142,7 @@
 # include	<sys/ioccom.h>
 # include	<sys/sysmacros.h>
 # include	<sys/kmem.h>
-# if defined(SOLARIS2) && SOLARIS2 >= 10
+# if SOLARIS2 >= 10
 #  include	<sys/procset.h>
 #  include	<sys/proc.h>
 #  include	<sys/devops.h>
@@ -154,7 +156,7 @@
 #  undef	RES_INIT
 # endif /* _KERNEL */
 
-# if defined(SOLARIS2) && SOLARIS2 >= 8
+# if SOLARIS2 >= 8
 #  include <netinet/ip6.h>
 #  include <netinet/icmp6.h>
 # endif
@@ -174,13 +176,16 @@
 # else
 #  include "radix_ipf_local.h"
 # endif
+# include <inet/mib2.h>
 # include <inet/ip.h>
 # undef COPYOUT
-# include <inet/ip_ire.h>
+# if !defined(_SYS_NETI_H)
+#  include <inet/ip_ire.h>
+# endif
 # ifndef	KERNEL
 #  undef	_KERNEL
 # endif
-# if defined(SOLARIS2) && SOLARIS2 >= 8
+# if SOLARIS2 >= 8
 #  define SNPRINTF	snprintf
 
 #  include <inet/ip_if.h>
@@ -195,13 +200,17 @@
 };
 # endif /* SOLARIS2 >= 8 */
 
-# if defined(SOLARIS2) && SOLARIS2 >= 6
+# if SOLARIS2 >= 6
 #  include <sys/atomic.h>
 typedef	uint32_t	u_32_t;
 # else
 typedef unsigned int	u_32_t;
 # endif
 # define	U_32_T	1
+# if SOLARIS2 >= 7
+#  define	U_QUAD_T	uint64_t
+#  define	QUAD_T		int64_t
+# endif
 
 # ifdef _KERNEL
 #  define	NEED_LOCAL_RAND	1
@@ -215,8 +224,9 @@
 #  else
 #   include <sys/neti.h>
 
-extern net_data_t ipfipv4;
-extern net_data_t ipfipv6;
+extern net_handle_t ipfipv4;
+extern net_handle_t ipfipv6;
+
 
 typedef struct qpktinfo {
         void		*qpi_data;
@@ -301,7 +311,8 @@
 					} \
 				} while (0)
 #  else
-#   define	 COPYIFNAME(v, x, b) \
+#   define	FASTROUTE_RECURSION	1
+#   define	COPYIFNAME(v, x, b) \
 				(void) strncpy(b, ((qif_t *)x)->qf_name, \
 					       LIFNAMSIZ)
 #  endif
@@ -322,7 +333,7 @@
 typedef mblk_t mb_t;
 # endif /* _KERNEL */
 
-# if defined(SOLARIS2) && (SOLARIS2 >= 7)
+# if (SOLARIS2 >= 7)
 #  ifdef lint
 #   define ALIGN32(ptr)    (ptr ? 0L : 0L)
 #   define ALIGN16(ptr)    (ptr ? 0L : 0L)
@@ -332,7 +343,7 @@
 #  endif
 # endif
 
-# if defined(SOLARIS2) && SOLARIS2 < 6
+# if SOLARIS2 < 6
 typedef	struct uio	uio_t;
 # endif
 typedef	int		ioctlcmd_t;
@@ -359,6 +370,7 @@
 # endif
 
 # ifdef _KERNEL
+#  define	FASTROUTE_RECURSION	1
 #  define SNPRINTF	sprintf
 #  if (HPUXREV >= 1111)
 #   define	IPL_SELECT
@@ -686,16 +698,16 @@
 #  define	ATOMIC_DEC64(x)		atomic_decq((uint64_t*)&(x))
 #  define	ATOMIC_INC32(x)		atomic_incl((uint32_t*)&(x))
 #  define	ATOMIC_DEC32(x)		atomic_decl((uint32_t*)&(x))
-#  define	ATOMIC_INC16(x)		{ simple_lock(&ipf_rw); (x)++; \
-					  simple_unlock(&ipf_rw); }
-#  define	ATOMIC_DEC16(x)		{ simple_lock(&ipf_rw); (x)--; \
-					  simple_unlock(&ipf_rw); }
+#  define	ATOMIC_INC16(x)		{ simple_lock(&ipf_rw.ipf_lk); (x)++; \
+					  simple_unlock(&ipf_rw.ipf_lk); }
+#  define	ATOMIC_DEC16(x)		{ simple_lock(&ipf_rw.ipf_lk); (x)--; \
+					  simple_unlock(&ipf_rw.ipf_lk); }
 #  define	ATOMIC_INCL(x)		atomic_incl((uint32_t*)&(x))
 #  define	ATOMIC_DECL(x)		atomic_decl((uint32_t*)&(x))
-#  define	ATOMIC_INC(x)		{ simple_lock(&ipf_rw); (x)++; \
-					  simple_unlock(&ipf_rw); }
-#  define	ATOMIC_DEC(x)		{ simple_lock(&ipf_rw); (x)--; \
-					  simple_unlock(&ipf_rw); }
+#  define	ATOMIC_INC(x)		{ simple_lock(&ipf_rw.ipf_lk); (x)++; \
+					  simple_unlock(&ipf_rw.ipf_lk); }
+#  define	ATOMIC_DEC(x)		{ simple_lock(&ipf_rw.ipf_lk); (x)--; \
+					  simple_unlock(&ipf_rw.ipf_lk); }
 #  define	SPL_SCHED(x)		;
 #  define	SPL_NET(x)		;
 #  define	SPL_IMP(x)		;
@@ -749,7 +761,7 @@
 	u_char	ip6e_len;
 };
 
-typedef	int		ioctlcmd_t;  
+typedef	int		ioctlcmd_t;
 /*
  * Really, any arch where sizeof(long) != sizeof(int).
  */
@@ -764,7 +776,11 @@
 /* ----------------------------------------------------------------------- */
 #ifdef __NetBSD__
 # if (NetBSD >= 199905) && !defined(IPFILTER_LKM) && defined(_KERNEL)
-#  include "opt_ipfilter.h"
+#  if (__NetBSD_Version__ < 399001400)
+#   include "opt_ipfilter_log.h"
+#  else
+#   include "opt_ipfilter.h"
+#  endif
 # endif
 # if defined(_KERNEL)
 #  include <sys/systm.h>
@@ -786,11 +802,32 @@
 
 # if (__NetBSD_Version__ >= 499000000)
 typedef	char *	caddr_t;
+#  ifdef _KERNEL
+#   include <sys/rwlock.h>
+#   define	USE_MUTEXES		1
+#   define	KMUTEX_T		kmutex_t
+#   define	KRWLOCK_T		krwlock_t
+#   define	MUTEX_DESTROY(x)	mutex_destroy(&(x)->ipf_lk)
+#   define	MUTEX_DOWNGRADE(x)	rw_downgrade(&(x)->ipf_lk)
+#   define	MUTEX_ENTER(x)		mutex_enter(&(x)->ipf_lk)
+#   define	MUTEX_EXIT(x)		mutex_exit(&(x)->ipf_lk)
+#   define	MUTEX_INIT(x,y)		mutex_init(&(x)->ipf_lk, MUTEX_DRIVER,\
+						  IPL_SOFTNET)
+#   define	MUTEX_NUKE(x)		bzero((x), sizeof(*(x)))
+#   define	READ_ENTER(x)		rw_enter(&(x)->ipf_lk, RW_READER)
+#   define	RWLOCK_INIT(x, y)	rw_init(&(x)->ipf_lk)
+#   define	RWLOCK_EXIT(x)		rw_exit(&(x)->ipf_lk)
+#   define	RW_DESTROY(x)		rw_destroy(&(x)->ipf_lk)
+#   define	WRITE_ENTER(x)		rw_enter(&(x)->ipf_lk, RW_WRITER)
+#   define	SPL_SCHED(x)		;
+#   define	SPL_NET(x)		;
+#   define	SPL_IMP(x)		;
+#   define	SPL_X(x)		;
+#  endif
 # endif
 
-# define	ipf_random	arc4random
-
 # ifdef _KERNEL
+#  define	ipf_random	arc4random
 #  if (__NetBSD_Version__ >= 399001400)
 #   define	KMALLOCS(a, b, c)	(a) = (b)malloc((c), _M_IPF, M_NOWAIT)
 #  endif
@@ -801,6 +838,9 @@
 #  define	IPF_PANIC(x,y)	if (x) { printf y; panic("ipf_panic"); }
 #  define	COPYIN(a,b,c)	copyin((caddr_t)(a), (caddr_t)(b), (c))
 #  define	COPYOUT(a,b,c)	copyout((caddr_t)(a), (caddr_t)(b), (c))
+#  if (defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 499004900))
+#   define	POLLWAKEUP(x)	selnotify(ipfselwait+x, 0, 0)
+#  endif
 typedef struct mbuf mb_t;
 # endif /* _KERNEL */
 # if (NetBSD <= 1991011) && (NetBSD >= 199606)
@@ -816,7 +856,7 @@
 				  ((struct ifnet *)fin->fin_ifp)->if_unit) & 7)
 # endif
 typedef	struct uio	uio_t;
-typedef	u_long		ioctlcmd_t;  
+typedef	u_long		ioctlcmd_t;
 typedef	int		minor_t;
 typedef	u_int32_t	u_32_t;
 # define	U_32_T	1
@@ -831,16 +871,12 @@
 #ifdef __FreeBSD__
 # if  (__FreeBSD_version < 400000)
 #  define	NEED_LOCAL_RAND	1
-# else
-#  define	ipf_random	arc4random
 # endif
 # if defined(_KERNEL)
-#  if (__FreeBSD_version >= 500000)                          
+#  if (__FreeBSD_version >= 500000)
 #   include "opt_bpf.h"
-#  else
-#   include "bpf.h"    
 #  endif
-#  if defined(__FreeBSD_version) && (__FreeBSD_version >= 400000)
+#  if defined(__FreeBSD_version) && (__FreeBSD_version >= 500000)
 #   include "opt_inet6.h"
 #  endif
 #  if defined(INET6) && !defined(USE_INET6)
@@ -849,7 +885,20 @@
 # endif
 
 # if defined(_KERNEL)
+#  if (__FreeBSD_version >= 500024)
+#   if (__FreeBSD_version >= 500043)
+#    define     p_cred  td_ucred
+#    define     p_uid   td_ucred->cr_ruid
+#   else
+#    define     p_cred  t_proc->p_cred
+#    define     p_uid   t_proc->p_cred->p_ruid
+#   endif
+#  else
+#   define      p_uid   p_cred->p_ruid
+#  endif /* __FreeBSD_version >= 500024 */
+
 #  if (__FreeBSD_version >= 400000)
+#   define	ipf_random	arc4random
 /*
  * When #define'd, the 5.2.1 kernel panics when used with the ftp proxy.
  * There may be other, safe, kernels but this is not extensively tested yet.
@@ -979,6 +1028,9 @@
 #  else
 #   define	SPL_SCHED(x)	x = splhigh()
 #  endif /* __FreeBSD_version >= 500043 */
+#  if (__FreeBSD_version >= 500024)
+#   define	GET_MINOR		dev2unit
+#  endif
 #  define	MSGDSIZE(x)	mbufchainlen(x)
 #  define	M_LEN(x)	(x)->m_len
 #  define	M_DUPLICATE(x)	m_copy((x), 0, M_COPYALL)
@@ -1055,7 +1107,7 @@
 # endif
 
 typedef	struct uio	uio_t;
-typedef	u_long		ioctlcmd_t;  
+typedef	u_long		ioctlcmd_t;
 typedef	int		minor_t;
 typedef	u_int32_t	u_32_t;
 # define	U_32_T	1
@@ -1123,7 +1175,7 @@
 # endif
 
 typedef	struct uio	uio_t;
-typedef	int		ioctlcmd_t;  
+typedef	int		ioctlcmd_t;
 typedef	int		minor_t;
 typedef	unsigned int	u_32_t;
 # define	U_32_T	1
@@ -1136,8 +1188,12 @@
 /*                            L I N U X                                    */
 /* ----------------------------------------------------------------------- */
 #if defined(linux) && !defined(OS_RECOGNISED)
-#include <linux/config.h>
-#include <linux/version.h>
+
+# include <linux/version.h>
+# if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+#  include <linux/config.h>
+# endif
+
 # if (LINUX >= 20600) && defined(_KERNEL)
 #  define	 HDR_T_PRIVATE	1
 # endif
@@ -1150,6 +1206,16 @@
 # endif
 
 # ifdef _KERNEL
+#  include <asm/byteorder.h>
+#  ifdef __LITTLE_ENDIAN
+#   define	LITTLE_ENDIAN	1
+#   define	BIG_ENDIAN	0
+#   define	BYTE_ORDER	LITTLE_ENDIAN
+#  else
+#   define	LITTLE_ENDIAN	0
+#   define	BIG_ENDIAN	1
+#   define	BYTE_ORDER	BIG_ENDIAN
+#  endif
 #  define	IPF_PANIC(x,y)	if (x) { printf y; panic("ipf_panic"); }
 #  define	COPYIN(a,b,c)	copy_from_user((caddr_t)(b), (caddr_t)(a), (c))
 #  define	COPYOUT(a,b,c)	copy_to_user((caddr_t)(b), (caddr_t)(a), (c))
@@ -1167,8 +1233,8 @@
 #  define	KRWLOCK_T		rwlock_t
 #  define	KMUTEX_T		spinlock_t
 #  define	MUTEX_INIT(x,y)		spin_lock_init(&(x)->ipf_lk)
-#  define	MUTEX_ENTER(x)		spin_lock(&(x)->ipf_lk)
-#  define	MUTEX_EXIT(x)		spin_unlock(&(x)->ipf_lk)
+#  define	MUTEX_ENTER(x)		spin_lock_bh(&(x)->ipf_lk)
+#  define	MUTEX_EXIT(x)		spin_unlock_bh(&(x)->ipf_lk)
 #  define	MUTEX_DESTROY(x)	do { } while (0)
 #  define	MUTEX_NUKE(x)		bzero(&(x)->ipf_lk, sizeof((x)->ipf_lk))
 #  define	READ_ENTER(x)		ipf_read_enter(x)
@@ -1208,6 +1274,7 @@
 #  define	mbuf	sk_buff
 
 #  define	mtod(m, t)	((t)(m)->data)
+#  define	m_adj(m, x)	skb_trim((m), (m)->len + (x))
 #  define	m_data		data
 #  define	m_len		len
 #  define	m_next		next
@@ -1221,10 +1288,18 @@
 #  define	bcopy(s,d,z)	memmove(d, s, z)
 #  define	bzero(s,z)	memset(s, 0, z)
 #  define	bcmp(a,b,z)	memcmp(a, b, z)
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+#   define	ipf_random	random32
+#   define	arc4random	random32
+#  else
+#   include <linux/random.h>
+#   define	ipf_random	get_random_int
+#   define	arc4random	get_random_int
+#  endif
 
 #  define	ifnet		net_device
 #  define	if_xname	name
-#  define	if_unit		ifindex 
+#  define	if_unit		ifindex
 
 #  define	KMALLOC(x,t)	(x) = (t)kmalloc(sizeof(*(x)), \
 				    in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)
@@ -1233,8 +1308,12 @@
 				    in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)
 #  define	KFREES(x,s)	kfree(x)
 
-#  define GETIFP(n,v)	dev_get_by_name(n)
-
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+#   define	f_uid		f_owner.uid
+#   define	GETIFP(n,v)	dev_get_by_name(&init_net,n)
+#  else
+#   define	GETIFP(n,v)	dev_get_by_name(n)
+#  endif
 # else
 #  include <net/ethernet.h>
 
@@ -1283,6 +1362,10 @@
 # define	UIO_READ	1
 # define	UIO_WRITE	2
 
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)) && !defined(_KERNEL)
+typedef int		fmode_t;
+# endif
+
 typedef	u_long		ioctlcmd_t;
 typedef	int		minor_t;
 typedef u_int32_t 	u_32_t;
@@ -1391,7 +1474,7 @@
 	u_char	ip6e_len;
 };
 
-typedef	int		ioctlcmd_t;  
+typedef	int		ioctlcmd_t;
 typedef	int		minor_t;
 /*
  * Really, any arch where sizeof(long) != sizeof(int).
@@ -1455,7 +1538,7 @@
 #ifdef KMUTEX_T
 	struct	{
 		KMUTEX_T	ipf_slk;
-		char		*ipf_lname;
+		const char	*ipf_lname;
 	} ipf_lkun_s;
 #endif
 	eMmutex_t	ipf_emu;
@@ -1465,7 +1548,7 @@
 #ifdef KRWLOCK_T
 	struct	{
 		KRWLOCK_T	ipf_slk;
-		char		*ipf_lname;
+		const char	*ipf_lname;
 		int		ipf_sr;
 		int		ipf_sw;
 		u_int		ipf_magic;
@@ -1591,13 +1674,15 @@
  * On BSD's use quad_t as a guarantee for getting at least a 64bit sized
  * object.
  */
-#if (BSD > 199306)
+#if !defined(__amd64__) && defined(BSD) && (BSD > 199306)
 # define	USE_QUAD_T
-# define	U_QUAD_T	unsigned long long
-# define	QUAD_T		long long
+# define	U_QUAD_T	u_quad_t
+# define	QUAD_T		quad_t
 #else /* BSD > 199306 */
-# define	U_QUAD_T	u_long
-# define	QUAD_T		long
+# if !defined(U_QUAD_T)
+#  define	U_QUAD_T	u_long
+#  define	QUAD_T		long
+# endif
 #endif /* BSD > 199306 */
 
 
@@ -1627,7 +1712,7 @@
 #  define	COPYDATA	m_copydata
 #  define	COPYBACK	m_copyback
 # endif
-# if (BSD >= 199306) || defined(__FreeBSD__)
+# if (defined(BSD) && (BSD >= 199306)) || defined(__FreeBSD__)
 #  if (defined(__NetBSD_Version__) && (__NetBSD_Version__ < 105180000)) || \
        defined(__FreeBSD__) || (defined(OpenBSD) && (OpenBSD < 200206)) || \
        defined(_BSDI_VERSION)
@@ -1662,27 +1747,18 @@
 #    endif /* M_IPFILTER */
 #   endif /* M_PFIL */
 #  endif /* IPFILTER_M_IPFILTER */
-#  if defined(__FreeBSD__) && __FreeBSD_version >= 800051
-#   define	KMALLOC(a, b)	do {			\
-	a = (b)malloc(sizeof(*(a)), _M_IPF, M_NOWAIT); \
-    } while (0)
-#   define	KMALLOCS(a, b, c)	do { \
-	a = (b)malloc((c), _M_IPF, ((c) > 4096) ? M_WAITOK : M_NOWAIT); \
-    } while (0)
-#   define	KFREE(x)	free((x), _M_IPF)
-#   define	KFREES(x,s)	free((x), _M_IPF)
-#  else
-#   define	KMALLOC(a, b)	MALLOC((a), b, sizeof(*(a)), _M_IPF, M_NOWAIT)
-#   if !defined(KMALLOCS)
-#    define	KMALLOCS(a, b, c)	MALLOC((a), b, (c), _M_IPF, M_NOWAIT)
-#   endif
-#   define	KFREE(x)	FREE((x), _M_IPF)
-#   define	KFREES(x,s)	FREE((x), _M_IPF)
+#  define	KMALLOC(a, b)	MALLOC((a), b, sizeof(*(a)), _M_IPF, M_NOWAIT)
+#  if !defined(KMALLOCS)
+#   define	KMALLOCS(a, b, c)	MALLOC((a), b, (c), _M_IPF, M_NOWAIT)
 #  endif
+#  define	KFREE(x)	FREE((x), _M_IPF)
+#  define	KFREES(x,s)	FREE((x), _M_IPF)
 #  define	UIOMOVE(a,b,c,d)	uiomove((caddr_t)a,b,d)
 #  define	SLEEP(id, n)	tsleep((id), PPAUSE|PCATCH, n, 0)
 #  define	WAKEUP(id,x)	wakeup(id+x)
-#  define	POLLWAKEUP(x)	selwakeup(ipfselwait+x)
+#  if !defined(POLLWAKEUP)
+#   define	POLLWAKEUP(x)	selwakeup(ipfselwait+x)
+#  endif
 #  define	GETIFP(n, v)	ifunit(n)
 # endif /* (Free)BSD */
 
@@ -1720,7 +1796,7 @@
 # endif
 
 # ifndef	GET_MINOR
-#  define	GET_MINOR(x)	dev2unit(x)
+#  define	GET_MINOR(x)	minor(x)
 # endif
 # define	PANIC(x,y)	if (x) panic y
 #endif /* _KERNEL */
@@ -1825,7 +1901,7 @@
 #endif
 
 #ifndef offsetof
-# define offsetof(t,m) (int)((&((t *)0L)->m))
+# define offsetof(t,m) (size_t)((&((t *)0L)->m))
 #endif
 
 /*
@@ -1872,9 +1948,9 @@
 #define	TCPF_ALL	(TH_FIN|TH_SYN|TH_RST|TH_PUSH|TH_ACK|TH_URG|\
 			 TH_ECN|TH_CWR)
 
-#if (BSD >= 199306) && !defined(m_act)
+#if (defined(BSD) && (BSD >= 199306)) && !defined(m_act)
 # define	m_act	m_nextpkt
-#endif  
+#endif
 
 /*
  * Security Options for Intenet Protocol (IPSO) as defined in RFC 1108.
@@ -1911,7 +1987,7 @@
  * IP option #defines
  */
 #undef	IPOPT_RR
-#define	IPOPT_RR	7 
+#define	IPOPT_RR	7
 #undef	IPOPT_ZSU
 #define	IPOPT_ZSU	10	/* ZSU */
 #undef	IPOPT_MTUP
@@ -2437,6 +2513,25 @@
 # define	ICMP6_NI_SUBJ_IPV4	2
 #endif
 
+#if !defined(IPV6_FLOWINFO_MASK)
+# if (BYTE_ORDER == BIG_ENDIAN) || defined(_BIG_ENDIAN)
+#  define IPV6_FLOWINFO_MASK	0x0fffffff	/* flow info (28 bits) */
+# else
+#  if(BYTE_ORDER == LITTLE_ENDIAN) || !defined(_BIG_ENDIAN)
+#   define IPV6_FLOWINFO_MASK	0xffffff0f	/* flow info (28 bits) */
+#  endif /* LITTLE_ENDIAN */
+# endif
+#endif
+#if !defined(IPV6_FLOWLABEL_MASK)
+# if (BYTE_ORDER == BIG_ENDIAN) || defined(_BIG_ENDIAN)
+#  define IPV6_FLOWLABEL_MASK	0x000fffff	/* flow label (20 bits) */
+# else
+#  if (BYTE_ORDER == LITTLE_ENDIAN) || !defined(_BIG_ENDIAN)
+#   define IPV6_FLOWLABEL_MASK	0xffff0f00	/* flow label (20 bits) */
+#  endif /* LITTLE_ENDIAN */
+# endif
+#endif
+
 /*
  * ECN is a new addition to TCP - RFC 2481
  */
diff -ur sys.orig/contrib/ipfilter/netinet/ip_fil.h sys/contrib/ipfilter/netinet/ip_fil.h
--- sys.orig/contrib/ipfilter/netinet/ip_fil.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_fil.h	2011-04-27 14:01:51.000000000 +0200
@@ -209,7 +208,7 @@
 		  } \
 		}
 #define	IP6_AND(a,b,d)	{ i6addr_t *_s1 = (i6addr_t *)(a); \
-			  i6addr_t *_s2 = (i6addr_t *)(d); \
+			  i6addr_t *_s2 = (i6addr_t *)(b); \
 			  i6addr_t *_d = (i6addr_t *)(d); \
 			  _d->i6[0] = _s1->i6[0] & _s2->i6[0]; \
 			  _d->i6[1] = _s1->i6[1] & _s2->i6[1]; \
@@ -269,6 +268,7 @@
 #define	FI_V6EXTHDR	0x10000
 #define	FI_COALESCE	0x20000
 #define	FI_NEWNAT	0x40000
+#define	FI_MOREFRAG	0x80000
 #define	FI_NOCKSUM	0x20000000	/* don't do a L4 checksum validation */
 #define	FI_DONTCACHE	0x40000000	/* don't cache the result */
 #define	FI_IGNORE	0x80000000
@@ -329,8 +329,7 @@
 	int	fin_depth;		/* Group nesting depth */
 	int	fin_error;		/* Error code to return */
 	int	fin_cksum;		/* -1 bad, 1 good, 0 not done */
-	void	*fin_nat;
-	void	*fin_state;
+	u_int	fin_pktnum;
 	void	*fin_nattag;
 	void	*fin_exthdr;
 	ip_t	*fin_ip;
@@ -521,8 +520,13 @@
 
 	/*
 	 * For PPS rate limiting
+	 * fr_lpu is used to always have the same size for this field,
+	 * allocating 64bits for seconds and 32bits for milliseconds.
 	 */
-	struct timeval	fr_lastpkt;
+	union {
+		struct timeval	frp_lastpkt;
+		char	frp_bytes[12];
+	} fr_lpu;
 	int		fr_curpps;
 
 	union	{
@@ -543,7 +547,7 @@
 	u_32_t	fr_flags;	/* per-rule flags && options (see below) */
 	u_32_t	fr_logtag;	/* user defined log tag # */
 	u_32_t	fr_collect;	/* collection number */
-	u_int	fr_arg;		/* misc. numeric arg for rule */ 
+	u_int	fr_arg;		/* misc. numeric arg for rule */
 	u_int	fr_loglevel;	/* syslog log facility + priority */
 	u_int	fr_age[2];	/* non-TCP timeouts */
 	u_char	fr_v;
@@ -561,6 +565,7 @@
 	u_int	fr_cksum;	/* checksum on filter rules for performance */
 } frentry_t;
 
+#define	fr_lastpkt	fr_lpu.frp_lastpkt
 #define	fr_caddr	fr_dun.fru_caddr
 #define	fr_data		fr_dun.fru_data
 #define	fr_dfunc	fr_dun.fru_func
@@ -628,7 +633,7 @@
 #define	FR_NOLOGTAG	0
 
 #ifndef	offsetof
-#define	offsetof(t,m)	(int)((&((t *)0L)->m))
+#define	offsetof(t,m)	(size_t)((&((t *)0L)->m))
 #endif
 #define	FR_CMPSIZ	(sizeof(struct frentry) - \
 			 offsetof(struct frentry, fr_func))
@@ -876,7 +881,7 @@
 	struct	frgroup		*f_groups[IPL_LOGSIZE][2];
 	u_long	f_froute[2];
 	u_long	f_ticks;
-	int	f_locks[IPL_LOGMAX];
+	int	f_locks[IPL_LOGSIZE];
 	size_t	f_kmutex_sz;
 	size_t	f_krwlock_sz;
 	int	f_defpass;	/* default pass - from fr_pass */
@@ -1068,7 +1073,7 @@
 					/* checks its timeout queues.       */
 #define	IPF_TTLVAL(x)	(((x) / IPF_HZ_MULT) * IPF_HZ_DIVIDE)
 
-typedef	int	(*ipftq_delete_fn_t)(void *);       
+typedef	int	(*ipftq_delete_fn_t)(void *);
 
 /*
  * Structure to define address for pool lookups.
@@ -1222,7 +1227,7 @@
 	int		ipt_type;
 	int		ipt_uid;
 	int		ipt_subtype;
-	int		ipt_alive;
+	int		ipt_ref;
 } ipftoken_t;
 
 
@@ -1364,7 +1369,7 @@
 #      endif
 #     endif /* __FreeBSD_version >= 500024 */
 #    else
-extern	int	iplioctl __P((dev_t, int, caddr_t, int, struct thread *));
+extern	int	iplioctl __P((dev_t, int, caddr_t, int, struct proc *));
 #    endif
 #    if (__FreeBSD_version >= 500024)
 #      if (__FreeBSD_version >= 502116)
@@ -1392,7 +1397,7 @@
 extern	int	iplioctl __P((dev_t, int, caddr_t, int));
 #    endif
 #   endif /* (_BSDI_VERSION >= 199510) */
-#   if	BSD >= 199306
+#   if defined(BSD) && (BSD >= 199306)
 #      if (__FreeBSD_version >= 502116)
 extern	int	iplread __P((struct cdev*, struct uio *, int));
 extern	int	iplwrite __P((struct cdev*, struct uio *, int));
@@ -1434,12 +1439,13 @@
 extern	int	copyinptr __P((void *, void *, size_t));
 extern	int	copyoutptr __P((void *, void *, size_t));
 extern	int	fr_fastroute __P((mb_t *, mb_t **, fr_info_t *, frdest_t *));
-extern	int	fr_inobj __P((void *, void *, int));
+extern	int	fr_inobj __P((void *, ipfobj_t *, void *, int));
 extern	int	fr_inobjsz __P((void *, void *, int, int));
 extern	int	fr_ioctlswitch __P((int, void *, ioctlcmd_t, int, int, void *));
 extern	int	fr_ipf_ioctl __P((caddr_t, ioctlcmd_t, int, int, void *));
 extern	int	fr_ipftune __P((ioctlcmd_t, void *));
 extern	int	fr_outobj __P((void *, void *, int));
+extern	int	fr_outobjk __P((ipfobj_t *, void *));
 extern	int	fr_outobjsz __P((void *, void *, int, int));
 extern	void	*fr_pullup __P((mb_t *, fr_info_t *, int));
 extern	void	fr_resolvedest __P((struct frdest *, int));
@@ -1447,7 +1453,8 @@
 extern	void	*fr_resolvenic __P((char *, int));
 extern	int	fr_send_icmp_err __P((int, fr_info_t *, int));
 extern	int	fr_send_reset __P((fr_info_t *));
-#if  (__FreeBSD_version < 501000) || !defined(_KERNEL)
+#if  (defined(__FreeBSD_version) && (__FreeBSD_version < 501000)) || \
+    !defined(_KERNEL) || defined(linux)
 extern	int	ppsratecheck __P((struct timeval *, int *, int));
 #endif
 extern	ipftq_t	*fr_addtimeoutqueue __P((ipftq_t **, u_int));
@@ -1498,7 +1505,6 @@
 extern	void		fr_fixskip __P((frentry_t **, frentry_t *, int));
 extern	void		fr_forgetifp __P((void *));
 extern	frentry_t 	*fr_getrulen __P((int, char *, u_32_t));
-extern	void		fr_getstat __P((struct friostat *));
 extern	int		fr_ifpaddr __P((int, int, void *,
 				struct in_addr *, struct in_addr *));
 extern	int		fr_initialise __P((void));
@@ -1510,13 +1516,13 @@
 extern	u_32_t		fr_newisn __P((fr_info_t *));
 extern	u_short		fr_nextipid __P((fr_info_t *));
 extern	int	ipf_queueflush __P((ipftq_delete_fn_t, ipftq_t *, ipftq_t *));
-extern	int		fr_rulen __P((int, frentry_t *));
 extern	int		fr_scanlist __P((fr_info_t *, u_32_t));
 extern	frentry_t 	*fr_srcgrpmap __P((fr_info_t *, u_32_t *));
 extern	int		fr_tcpudpchk __P((fr_info_t *, frtuc_t *));
 extern	int		fr_verifysrc __P((fr_info_t *fin));
 extern	int		fr_zerostats __P((void *));
 extern	ipftoken_t	*ipf_findtoken __P((int, int, void *));
+extern	void		ipf_dereftoken __P((ipftoken_t *));
 extern	int		ipf_getnextrule __P((ipftoken_t *, void *));
 extern	void		ipf_expiretokens __P((void));
 extern	void		ipf_freetoken __P((ipftoken_t *));
@@ -1549,7 +1555,7 @@
 extern	u_long	fr_ticks;
 extern	fr_info_t	frcache[2][8];
 extern	char	ipfilter_version[];
-extern	iplog_t	**iplh[IPL_LOGMAX+1], *iplt[IPL_LOGMAX+1];
+extern	iplog_t	**iplh[IPL_LOGSIZE], *iplt[IPL_LOGSIZE];
 extern	int	iplused[IPL_LOGMAX + 1];
 extern	struct frentry *ipfilter[2][2], *ipacct[2][2];
 #ifdef	USE_INET6
@@ -1558,6 +1564,10 @@
 extern	int	icmptoicmp6unreach[ICMP_MAX_UNREACH];
 extern	int	icmpreplytype6[ICMP6_MAXTYPE + 1];
 #endif
+#ifdef	IPFILTER_COMPAT
+extern	int	fr_in_compat __P((ipfobj_t *, void *));
+extern	int	fr_out_compat __P((ipfobj_t *, void *));
+#endif
 extern	int	icmpreplytype4[ICMP_MAXTYPE + 1];
 extern	struct frgroup *ipfgroups[IPL_LOGSIZE][2];
 extern	struct filterstats frstats[];
diff -ur sys.orig/contrib/ipfilter/netinet/ip_fil_freebsd.c sys/contrib/ipfilter/netinet/ip_fil_freebsd.c
--- sys.orig/contrib/ipfilter/netinet/ip_fil_freebsd.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_fil_freebsd.c	2011-04-27 13:03:01.000000000 +0200
@@ -62,12 +60,6 @@
 #else
 # include <sys/select.h>
 #endif
-#if __FreeBSD_version >= 800044
-# include <netinet/tcp_var.h>
-#else
-#define V_path_mtu_discovery path_mtu_discovery
-#define V_ipforwarding ipforwarding
-#endif
 
 #include <net/if.h>
 #if __FreeBSD_version >= 300000
@@ -121,19 +113,15 @@
 #endif
 extern	int	ip_optcopy __P((struct ip *, struct ip *));
 
-#if (__FreeBSD_version > 460000) && (__FreeBSD_version < 800055)
+#if (__FreeBSD_version > 460000)
 extern	int	path_mtu_discovery;
 #endif
 
 # ifdef IPFILTER_M_IPFILTER
-MALLOC_DEFINE(M_IPFILTER, "ipfilter", "IP Filter packet filter data structures");
+MALLOC_DEFINE(M_IPFILTER, "IP Filter", "IP Filter packet filter data structures");
 # endif
 
 
-#if !defined(__osf__)
-extern	struct	protosw	inetsw[];
-#endif
-
 static	int	(*fr_savep) __P((ip_t *, int, void *, int, struct mbuf **));
 static	int	fr_send_ip __P((fr_info_t *, mb_t *, mb_t **));
 # ifdef USE_MUTEXES
@@ -153,7 +141,7 @@
 # include <sys/conf.h>
 # if defined(NETBSD_PF)
 #  include <net/pfil.h>
-#  if (__FreeBSD_version < 501108)
+#  if (__FreeBSD_version < 800000)
 #   include <netinet/ipprotosw.h>
 #  endif
 /*
@@ -242,7 +230,7 @@
 	fr_running = 1;
 
 	if (fr_control_forwarding & 1)
-		V_ipforwarding = 1;
+		ipforwarding = 1;
 
 	SPL_X(s);
 #if (__FreeBSD_version >= 300000)
@@ -265,7 +253,7 @@
 	int s;
 #endif
 	if (fr_control_forwarding & 2)
-		V_ipforwarding = 0;
+		ipforwarding = 0;
 
 	SPL_NET(s);
 
@@ -313,10 +301,8 @@
 #  if (__FreeBSD_version >= 500024)
 struct thread *p;
 #   if (__FreeBSD_version >= 500043)
-#    define	p_cred	td_ucred
 #    define	p_uid	td_ucred->cr_ruid
 #   else
-#    define	p_cred	t_proc->p_cred
 #    define	p_uid	t_proc->p_cred->p_ruid
 #   endif
 #  else
@@ -435,13 +421,35 @@
 #endif
 int flags;
 {
-	u_int min = GET_MINOR(dev);
+	u_int unit = GET_MINOR(dev);
+	int error;
 
-	if (IPL_LOGMAX < min)
-		min = ENXIO;
-	else
-		min = 0;
-	return min;
+	if (IPL_LOGMAX < unit)
+		error = ENXIO;
+	else {
+		switch (unit)
+		{
+		case IPL_LOGIPF :
+		case IPL_LOGNAT :
+		case IPL_LOGSTATE :
+		case IPL_LOGAUTH :
+#ifdef IPFILTER_LOOKUP
+		case IPL_LOGLOOKUP :
+#endif
+#ifdef IPFILTER_SYNC
+		case IPL_LOGSYNC :
+#endif
+#ifdef IPFILTER_SCAN
+		case IPL_LOGSCAN :
+#endif
+			error = 0;
+			break;
+		default :
+			error = ENXIO;
+			break;
+		}
+	}
+	return error;
 }
 
 
@@ -464,13 +472,13 @@
 #endif
 int flags;
 {
-	u_int	min = GET_MINOR(dev);
+	u_int	unit = GET_MINOR(dev);
 
-	if (IPL_LOGMAX < min)
-		min = ENXIO;
+	if (IPL_LOGMAX < unit)
+		unit = ENXIO;
 	else
-		min = 0;
-	return min;
+		unit = 0;
+	return unit;
 }
 
 /*
@@ -492,21 +500,21 @@
 #endif
 register struct uio *uio;
 {
-	u_int	xmin = GET_MINOR(dev);
+	u_int	unit = GET_MINOR(dev);
 
 	if (fr_running < 1)
 		return EIO;
 
-	if (xmin < 0)
+	if (unit < 0)
 		return ENXIO;
 
 # ifdef	IPFILTER_SYNC
-	if (xmin == IPL_LOGSYNC)
+	if (unit == IPL_LOGSYNC)
 		return ipfsync_read(uio);
 # endif
 
 #ifdef IPFILTER_LOG
-	return ipflog_read(xmin, uio);
+	return ipflog_read(unit, uio);
 #else
 	return ENXIO;
 #endif
@@ -666,11 +674,11 @@
 		ip->ip_tos = oip->ip_tos;
 		ip->ip_id = fin->fin_ip->ip_id;
 #if (__FreeBSD_version > 460000)
-		ip->ip_off = V_path_mtu_discovery ? IP_DF : 0;
+		ip->ip_off = path_mtu_discovery ? IP_DF : 0;
 #else
 		ip->ip_off = 0;
 #endif
-		ip->ip_ttl = V_ip_defttl;
+		ip->ip_ttl = ip_defttl;
 		ip->ip_sum = 0;
 		hlen = sizeof(*oip);
 		break;
@@ -703,6 +711,14 @@
 	fnew.fin_dp = (char *)ip + hlen;
 	(void) fr_makefrip(hlen, ip, &fnew);
 
+	if (fin->fin_fr != NULL && fin->fin_fr->fr_type == FR_T_IPF) {
+		frdest_t *fdp = &fin->fin_fr->fr_rif;
+
+		if ((fdp->fd_ifp != NULL) &&
+		    (fdp->fd_ifp != (struct ifnet *)-1))
+			return fr_fastroute(m, mpp, &fnew, fdp);
+	}
+
 	return fr_fastroute(m, mpp, &fnew, NULL);
 }
 
@@ -748,8 +764,7 @@
 	ohlen = 0;
 	ifp = fin->fin_ifp;
 	if (fin->fin_v == 4) {
-		if ((fin->fin_p == IPPROTO_ICMP) &&
-		    !(fin->fin_flx & FI_SHORT))
+		if ((fin->fin_p == IPPROTO_ICMP) && !(fin->fin_flx & FI_SHORT))
 			switch (ntohs(fin->fin_data[0]) >> 8)
 			{
 			case ICMP_ECHO :
@@ -949,10 +964,11 @@
 		 * currently "to <if>" and "to <if>:ip#" are not supported
 		 * for IPv6
 		 */
+		*mpp = NULL;
 #if  (__FreeBSD_version >= 490000)
-		return ip6_output(m0, NULL, NULL, 0, NULL, NULL, NULL);
+		return ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
 #else
-		return ip6_output(m0, NULL, NULL, 0, NULL, NULL);
+		return ip6_output(m, NULL, NULL, 0, NULL, NULL);
 #endif
 	}
 #endif
@@ -984,7 +1000,7 @@
 		dst->sin_addr = fdp->fd_ip;
 
 	dst->sin_len = sizeof(*dst);
-	in_rtalloc(ro, 0);
+	rtalloc(ro);
 
 	if ((ifp == NULL) && (ro->ro_rt != NULL))
 		ifp = ro->ro_rt->rt_ifp;
@@ -1017,8 +1033,7 @@
 		if (!fr || !(fr->fr_flags & FR_RETMASK)) {
 			u_32_t pass;
 
-			if (fr_checkstate(fin, &pass) != NULL)
-				fr_statederef((ipstate_t **)&fin->fin_state);
+			(void) fr_checkstate(fin, &pass);
 		}
 
 		switch (fr_checknatout(fin, NULL))
@@ -1026,7 +1041,6 @@
 		case 0 :
 			break;
 		case 1 :
-			fr_natderef((nat_t **)&fin->fin_nat);
 			ip->ip_sum = 0;
 			break;
 		case -1 :
@@ -1049,7 +1063,12 @@
 		if (!ip->ip_sum)
 			ip->ip_sum = in_cksum(m, hlen);
 		error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst,
-					  ro);
+#if (__FreeBSD_version < 800000)
+			    ro->ro_rt
+#else
+			    ro
+#endif
+			);
 		goto done;
 	}
 	/*
@@ -1130,11 +1149,17 @@
 		m->m_act = 0;
 		if (error == 0)
 			error = (*ifp->if_output)(ifp, m,
-			    (struct sockaddr *)dst, ro);
+			    (struct sockaddr *)dst,
+#if (__FreeBSD_version < 800000)
+			    ro->ro_rt
+#else
+			    ro
+#endif
+			    );
 		else
 			FREE_MB_T(m);
 	}
-    }	
+    }
 done:
 	if (!error)
 		fr_frouteok[0]++;
@@ -1172,7 +1197,7 @@
 	dst->sin_len = sizeof(*dst);
 	dst->sin_family = AF_INET;
 	dst->sin_addr = fin->fin_src;
-	in_rtalloc(&iproute, 0);
+	rtalloc(&iproute);
 	if (iproute.ro_rt == NULL)
 		return 0;
 	return (fin->fin_ifp == iproute.ro_rt->rt_ifp);
@@ -1430,13 +1455,13 @@
 /* We assume that 'min' is a pointer to a buffer that is part of the chain  */
 /* of buffers that starts at *fin->fin_mp.                                  */
 /* ------------------------------------------------------------------------ */
-void *fr_pullup(min, fin, len)
-mb_t *min;
+void *fr_pullup(xmin, fin, len)
+mb_t *xmin;
 fr_info_t *fin;
 int len;
 {
 	int out = fin->fin_out, dpoff, ipoff;
-	mb_t *m = min;
+	mb_t *m = xmin;
 	char *ip;
 
 	if (m == NULL)
@@ -1453,12 +1478,25 @@
 		dpoff = 0;
 
 	if (M_LEN(m) < len) {
-#ifdef MHLEN
+		mb_t *n = *fin->fin_mp;
 		/*
 		 * Assume that M_PKTHDR is set and just work with what is left
 		 * rather than check..
 		 * Should not make any real difference, anyway.
 		 */
+		if (m != n) {
+			/*
+			 * Record the mbuf that points to the mbuf that we're
+			 * about to go to work on so that we can update the
+			 * m_next appropriately later.
+			 */
+			for (; n->m_next != m; n = n->m_next)
+				;
+		} else {
+			n = NULL;
+		}
+
+#ifdef MHLEN
 		if (len > MHLEN)
 #else
 		if (len > MLEN)
@@ -1470,29 +1508,44 @@
 #else
 			FREE_MB_T(*fin->fin_mp);
 			m = NULL;
+			n = NULL;
 #endif
 		} else
 		{
 			m = m_pullup(m, len);
 		}
-		*fin->fin_mp = m;
+		if (n != NULL)
+			n->m_next = m;
 		if (m == NULL) {
+			/*
+			 * When n is non-NULL, it indicates that m pointed to
+			 * a sub-chain (tail) of the mbuf and that the head
+			 * of this chain has not yet been free'd.
+			 */
+			if (n != NULL) {
+				FREE_MB_T(*fin->fin_mp);
+			}
+
+			*fin->fin_mp = NULL;
 			fin->fin_m = NULL;
 			ATOMIC_INCL(frstats[out].fr_pull[1]);
 			return NULL;
 		}
 
+		if (n == NULL)
+			*fin->fin_mp = m;
+
 		while (M_LEN(m) == 0) {
 			m = m->m_next;
 		}
 		fin->fin_m = m;
 		ip = MTOD(m, char *) + ipoff;
-	}
 
-	ATOMIC_INCL(frstats[out].fr_pull[0]);
-	fin->fin_ip = (ip_t *)ip;
-	if (fin->fin_dp != NULL)
-		fin->fin_dp = (char *)fin->fin_ip + dpoff;
+		ATOMIC_INCL(frstats[out].fr_pull[0]);
+		fin->fin_ip = (ip_t *)ip;
+		if (fin->fin_dp != NULL)
+			fin->fin_dp = (char *)fin->fin_ip + dpoff;
+	}
 
 	if (len == fin->fin_plen)
 		fin->fin_flx |= FI_COALESCE;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_frag.c sys/contrib/ipfilter/netinet/ip_frag.c
--- sys.orig/contrib/ipfilter/netinet/ip_frag.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_frag.c	2011-04-27 13:03:01.000000000 +0200
@@ -62,7 +62,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -130,6 +128,7 @@
 u_long	fr_ticks = 0;
 
 
+static INLINE int ipfr_index __P((fr_info_t *, ipfr_t *));
 static ipfr_t *ipfr_newfrag __P((fr_info_t *, u_32_t, ipfr_t **));
 static ipfr_t *fr_fraglookup __P((fr_info_t *, ipfr_t **));
 static void fr_fragdelete __P((ipfr_t *, ipfr_t ***));
@@ -214,6 +213,76 @@
 
 
 /* ------------------------------------------------------------------------ */
+/* Function:    ipfr_index                                                  */
+/* Returns:     int     - index in fragment table for given packet          */
+/* Parameters:  fin(I)  - pointer to packet information                     */
+/*              frag(O) - pointer to ipfr_t structure to fill               */
+/*                                                                          */
+/* Compute the index in the fragment table while filling the per packet     */
+/* part of the fragment state.                                              */
+/* ------------------------------------------------------------------------ */
+static INLINE int ipfr_index(fin, frag)
+fr_info_t *fin;
+ipfr_t *frag;
+{
+	u_int idx;
+
+	/*
+	 * For fragments, we record protocol, packet id, TOS and both IP#'s
+	 * (these should all be the same for all fragments of a packet).
+	 *
+	 * build up a hash value to index the table with.
+	 */
+
+#ifdef	USE_INET6
+	if (fin->fin_v == 6) {
+		ip6_t *ip6 = (ip6_t *)fin->fin_ip;
+
+		frag->ipfr_p = fin->fin_fi.fi_p;
+		frag->ipfr_id = fin->fin_id;
+		frag->ipfr_tos = ip6->ip6_flow & IPV6_FLOWINFO_MASK;
+		frag->ipfr_src.in6 = ip6->ip6_src;
+		frag->ipfr_dst.in6 = ip6->ip6_dst;
+	} else
+#endif
+	{
+		ip_t *ip = fin->fin_ip;
+
+		frag->ipfr_p = ip->ip_p;
+		frag->ipfr_id = ip->ip_id;
+		frag->ipfr_tos = ip->ip_tos;
+		frag->ipfr_src.in4.s_addr = ip->ip_src.s_addr;
+		frag->ipfr_src.i6[1] = 0;
+		frag->ipfr_src.i6[2] = 0;
+		frag->ipfr_src.i6[3] = 0;
+		frag->ipfr_dst.in4.s_addr = ip->ip_dst.s_addr;
+		frag->ipfr_dst.i6[1] = 0;
+		frag->ipfr_dst.i6[2] = 0;
+		frag->ipfr_dst.i6[3] = 0;
+	}
+	frag->ipfr_ifp = fin->fin_ifp;
+	frag->ipfr_optmsk = fin->fin_fi.fi_optmsk & IPF_OPTCOPY;
+	frag->ipfr_secmsk = fin->fin_fi.fi_secmsk;
+	frag->ipfr_auth = fin->fin_fi.fi_auth;
+
+	idx = frag->ipfr_p;
+	idx += frag->ipfr_id;
+	idx += frag->ipfr_src.i6[0];
+	idx += frag->ipfr_src.i6[1];
+	idx += frag->ipfr_src.i6[2];
+	idx += frag->ipfr_src.i6[3];
+	idx += frag->ipfr_dst.i6[0];
+	idx += frag->ipfr_dst.i6[1];
+	idx += frag->ipfr_dst.i6[2];
+	idx += frag->ipfr_dst.i6[3];
+	idx *= 127;
+	idx %= IPFT_SIZE;
+
+	return idx;
+}
+
+
+/* ------------------------------------------------------------------------ */
 /* Function:    ipfr_newfrag                                                */
 /* Returns:     ipfr_t * - pointer to fragment cache state info or NULL     */
 /* Parameters:  fin(I)   - pointer to packet information                    */
@@ -230,36 +299,18 @@
 	ipfr_t *fra, frag;
 	u_int idx, off;
 	frentry_t *fr;
-	ip_t *ip;
 
-	if (ipfr_inuse >= IPFT_SIZE)
+	if (ipfr_inuse >= ipfr_size)
 		return NULL;
 
 	if ((fin->fin_flx & (FI_FRAG|FI_BAD)) != FI_FRAG)
 		return NULL;
 
-	ip = fin->fin_ip;
-
 	if (pass & FR_FRSTRICT)
 		if (fin->fin_off != 0)
 			return NULL;
 
-	frag.ipfr_p = ip->ip_p;
-	idx = ip->ip_p;
-	frag.ipfr_id = ip->ip_id;
-	idx += ip->ip_id;
-	frag.ipfr_tos = ip->ip_tos;
-	frag.ipfr_src.s_addr = ip->ip_src.s_addr;
-	idx += ip->ip_src.s_addr;
-	frag.ipfr_dst.s_addr = ip->ip_dst.s_addr;
-	idx += ip->ip_dst.s_addr;
-	frag.ipfr_ifp = fin->fin_ifp;
-	idx *= 127;
-	idx %= IPFT_SIZE;
-
-	frag.ipfr_optmsk = fin->fin_fi.fi_optmsk & IPF_OPTCOPY;
-	frag.ipfr_secmsk = fin->fin_fi.fi_secmsk;
-	frag.ipfr_auth = fin->fin_fi.fi_auth;
+	idx = ipfr_index(fin, &frag);
 
 	/*
 	 * first, make sure it isn't already there...
@@ -305,7 +356,7 @@
 	/*
 	 * Compute the offset of the expected start of the next packet.
 	 */
-	off = ip->ip_off & IP_OFFMASK;
+	off = fin->fin_off >> 3;
 	if (off == 0)
 		fra->ipfr_seen0 = 1;
 	fra->ipfr_off = off + (fin->fin_dlen >> 3);
@@ -330,7 +381,7 @@
 {
 	ipfr_t	*fra;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock != 0))
+	if (fr_frag_lock != 0)
 		return -1;
 
 	WRITE_ENTER(&ipf_frag);
@@ -364,7 +415,7 @@
 {
 	ipfr_t	*fra;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock != 0))
+	if (fr_frag_lock != 0)
 		return 0;
 
 	WRITE_ENTER(&ipf_natfrag);
@@ -397,13 +448,13 @@
 {
 	ipfr_t	*fra;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock))
+	if (fr_frag_lock)
 		return 0;
 
 	WRITE_ENTER(&ipf_ipidfrag);
 	fra = ipfr_newfrag(fin, 0, ipfr_ipidtab);
 	if (fra != NULL) {
-		fra->ipfr_data = (void *)(uintptr_t)ipid;
+		fra->ipfr_data = (void *)((u_long)ipid);
 		*ipfr_ipidtail = fra;
 		fra->ipfr_prev = ipfr_ipidtail;
 		ipfr_ipidtail = &fra->ipfr_next;
@@ -430,7 +481,6 @@
 {
 	ipfr_t *f, frag;
 	u_int idx;
-	ip_t *ip;
 
 	if ((fin->fin_flx & (FI_FRAG|FI_BAD)) != FI_FRAG)
 		return NULL;
@@ -441,19 +491,7 @@
 	 *
 	 * build up a hash value to index the table with.
 	 */
-	ip = fin->fin_ip;
-	frag.ipfr_p = ip->ip_p;
-	idx = ip->ip_p;
-	frag.ipfr_id = ip->ip_id;
-	idx += ip->ip_id;
-	frag.ipfr_tos = ip->ip_tos;
-	frag.ipfr_src.s_addr = ip->ip_src.s_addr;
-	idx += ip->ip_src.s_addr;
-	frag.ipfr_dst.s_addr = ip->ip_dst.s_addr;
-	idx += ip->ip_dst.s_addr;
-	frag.ipfr_ifp = fin->fin_ifp;
-	idx *= 127;
-	idx %= IPFT_SIZE;
+	idx = ipfr_index(fin, &frag);
 
 	frag.ipfr_optmsk = fin->fin_fi.fi_optmsk & IPF_OPTCOPY;
 	frag.ipfr_secmsk = fin->fin_fi.fi_secmsk;
@@ -488,7 +526,7 @@
 			 * because a fragmented packet is never resent with
 			 * the same IP ID# (or shouldn't).
 			 */
-			off = ip->ip_off & IP_OFFMASK;
+			off = fin->fin_off >> 3;
 			if (f->ipfr_seen0) {
 				if (off == 0) {
 					ATOMIC_INCL(ipfr_stats.ifs_retrans0);
@@ -522,7 +560,7 @@
 			 * last (in order), shrink expiration time.
 			 */
 			if (off == f->ipfr_off) {
-				if (!(ip->ip_off & IP_MF))
+				if (!(fin->fin_flx & FI_MOREFRAG))
 					f->ipfr_ttl = fr_ticks + 1;
 				f->ipfr_off = (fin->fin_dlen >> 3) + off;
 			} else if (f->ipfr_pass & FR_FRSTRICT)
@@ -548,7 +586,7 @@
 	nat_t	*nat;
 	ipfr_t	*ipf;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock) || !ipfr_natlist)
+	if ((fr_frag_lock) || !ipfr_natlist)
 		return NULL;
 	READ_ENTER(&ipf_natfrag);
 	ipf = fr_fraglookup(fin, ipfr_nattab);
@@ -582,13 +620,13 @@
 	ipfr_t	*ipf;
 	u_32_t	id;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock) || !ipfr_ipidlist)
+	if ((fr_frag_lock) || !ipfr_ipidlist)
 		return 0xffffffff;
 
 	READ_ENTER(&ipf_ipidfrag);
 	ipf = fr_fraglookup(fin, ipfr_ipidtab);
 	if (ipf != NULL)
-		id = (u_32_t)(uintptr_t)ipf->ipfr_data;
+		id = (u_32_t)((u_long)ipf->ipfr_data & 0xffffffff);
 	else
 		id = 0xffffffff;
 	RWLOCK_EXIT(&ipf_ipidfrag);
@@ -615,7 +653,7 @@
 	ipfr_t	*fra;
 	u_32_t pass;
 
-	if ((fin->fin_v != 4) || (fr_frag_lock) || (ipfr_list == NULL))
+	if ((fr_frag_lock) || (ipfr_list == NULL))
 		return NULL;
 
 	READ_ENTER(&ipf_frag);
@@ -921,18 +959,21 @@
 	ipfr_t *frag, *next, zero;
 	int error = 0;
 
-	frag = token->ipt_data;
-	if (frag == (ipfr_t *)-1) {
-		ipf_freetoken(token);
-		return ESRCH;
-	}
-
 	READ_ENTER(lock);
+
+	/*
+	 * Retrieve "previous" entry from token and find the next entry.
+	 */
+	frag = token->ipt_data;
 	if (frag == NULL)
 		next = *top;
 	else
 		next = frag->ipfr_next;
 
+	/*
+	 * If we found an entry, add reference to it and update token.
+	 * Otherwise, zero out data to be returned and NULL out token.
+	 */
 	if (next != NULL) {
 		ATOMIC_INC(next->ipfr_ref);
 		token->ipt_data = next;
@@ -941,20 +982,28 @@
 		next = &zero;
 		token->ipt_data = NULL;
 	}
+
+	/*
+	 * Now that we have ref, it's save to give up lock.
+	 */
 	RWLOCK_EXIT(lock);
 
-	if (frag != NULL) {
+	/*
+	 * Copy out data and clean up references and token as needed.
+	 */
+	error = COPYOUT(next, itp->igi_data, sizeof(*next));
+	if (error != 0)
+		error = EFAULT;
+	if (token->ipt_data != NULL) {
+		if (frag != NULL)
 #ifdef USE_MUTEXES
-		fr_fragderef(&frag, lock);
+			fr_fragderef(&frag, lock);
 #else
-		fr_fragderef(&frag);
+			fr_fragderef(&frag);
 #endif
+		if (next->ipfr_next == NULL)
+			token->ipt_data = NULL;
 	}
-
-	error = COPYOUT(next, itp->igi_data, sizeof(*next));
-	if (error != 0)
-		error = EFAULT;
-
 	return error;
 }
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_frag.h sys/contrib/ipfilter/netinet/ip_frag.h
--- sys.orig/contrib/ipfilter/netinet/ip_frag.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_frag.h	2011-04-27 13:03:01.000000000 +0200
@@ -30,14 +27,14 @@
 	 * therefore important for this set to remain together.
 	 */
 	void	*ipfr_ifp;
-	struct	in_addr	ipfr_src;
-	struct	in_addr	ipfr_dst;
+	i6addr_t ipfr_src;
+	i6addr_t ipfr_dst;
 	u_32_t	ipfr_optmsk;
 	u_short	ipfr_secmsk;
 	u_short	ipfr_auth;
-	u_short	ipfr_id;
-	u_char	ipfr_p;
-	u_char	ipfr_tos;
+	u_32_t	ipfr_id;
+	u_32_t	ipfr_p;
+	u_32_t	ipfr_tos;
 	u_32_t	ipfr_pass;
 } ipfr_t;
 
@@ -90,8 +87,8 @@
 extern	void	fr_fragclear __P((void));
 extern	void	fr_fragexpire __P((void));
 
-#if     defined(_KERNEL) && ((BSD >= 199306) || SOLARIS || defined(__sgi) \
-	        || defined(__osf__) || (defined(__sgi) && (IRIX >= 60500)))
+#if defined(_KERNEL) && ((defined(BSD) && (BSD >= 199306)) || SOLARIS || \
+    defined(__sgi) || defined(__osf__) || (defined(__sgi) && (IRIX >= 60500)))
 # if defined(SOLARIS2) && (SOLARIS2 < 7)
 extern	void	fr_slowtimer __P((void));
 # else
diff -ur sys.orig/contrib/ipfilter/netinet/ip_ftp_pxy.c sys/contrib/ipfilter/netinet/ip_ftp_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_ftp_pxy.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_ftp_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -38,6 +35,11 @@
 #define	FTPXY_PASS_2	14
 #define	FTPXY_PAOK_2	15
 
+#define	FTPXY_JUNK_OK	0
+#define	FTPXY_JUNK_BAD	1	/* Ignore all commands for this connection */
+#define	FTPXY_JUNK_EOL	2	/* consume the rest of this line only */
+#define	FTPXY_JUNK_CONT	3	/* Saerching for next numeric */
+
 /*
  * Values for FTP commands.  Numerics cover 0-999
  */
@@ -313,8 +315,6 @@
 	 * mapping.
 	 */
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_flx |= FI_IGNORE;
 	fi.fin_data[0] = sp;
 	fi.fin_data[1] = fin->fin_data[1] - 1;
@@ -359,19 +359,21 @@
 		flags = NAT_SLAVE|IPN_TCP|SI_W_DPORT;
 		if (nat->nat_dir == NAT_INBOUND)
 			flags |= NAT_NOTRULEPORT;
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL, flags, nat->nat_dir);
+		MUTEX_EXIT(&ipf_nat_new);
 
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, IPN_TCP);
-			nat_update(&fi, nat2, nat->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 			fi.fin_ifp = NULL;
 			if (nat->nat_dir == NAT_INBOUND) {
 				fi.fin_fi.fi_daddr = nat->nat_inip.s_addr;
 				ip->ip_dst = nat->nat_inip;
 			}
 			(void) fr_addstate(&fi, NULL, SI_W_DPORT);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 		ip->ip_len = slen;
 		ip->ip_src = swip;
@@ -658,8 +660,6 @@
 	 * other way.
 	 */
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_flx |= FI_IGNORE;
 	fi.fin_data[0] = 0;
 	fi.fin_data[1] = port;
@@ -709,18 +709,20 @@
 		nflags |= NAT_SLAVE;
 		if (nat->nat_dir == NAT_INBOUND)
 			nflags |= NAT_NOTRULEPORT;
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL, nflags, nat->nat_dir);
+		MUTEX_EXIT(&ipf_nat_new);
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, IPN_TCP);
-			nat_update(&fi, nat2, nat->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 			fi.fin_ifp = NULL;
 			if (nat->nat_dir == NAT_INBOUND) {
 				fi.fin_fi.fi_daddr = nat->nat_inip.s_addr;
 				ip->ip_dst = nat->nat_inip;
 			}
 			(void) fr_addstate(&fi, NULL, sflags);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 
 		ip->ip_len = slen;
@@ -809,8 +811,8 @@
 
 	s = buf;
 
-	if (ftps->ftps_junk == 1)
-		return 1;
+	if (ftps->ftps_junk == FTPXY_JUNK_BAD)
+		return FTPXY_JUNK_BAD;
 
 	if (i < 5) {
 		if (ippr_ftp_debug > 3)
@@ -852,7 +854,7 @@
 			       "ippr_ftp_client_valid",
 			       ftps->ftps_junk, (int)len, (int)i, c,
 			       (int)len, (int)len, buf);
-		return 1;
+		return FTPXY_JUNK_BAD;
 	}
 
 	for (; i; i--) {
@@ -871,7 +873,7 @@
 	printf("ippr_ftp_client_valid:junk after cmd[%*.*s]\n",
 	       (int)len, (int)len, buf);
 #endif
-	return 2;
+	return FTPXY_JUNK_EOL;
 }
 
 
@@ -887,8 +889,8 @@
 	s = buf;
 	cmd = 0;
 
-	if (ftps->ftps_junk == 1)
-		return 1;
+	if (ftps->ftps_junk == FTPXY_JUNK_BAD)
+		return FTPXY_JUNK_BAD;
 
 	if (i < 5) {
 		if (ippr_ftp_debug > 3)
@@ -898,8 +900,10 @@
 
 	c = *s++;
 	i--;
-	if (c == ' ')
+	if (c == ' ') {
+		cmd = -1;
 		goto search_eol;
+	}
 
 	if (ISDIGIT(c)) {
 		cmd = (c - '0') * 100;
@@ -915,6 +919,8 @@
 				i--;
 				if ((c != '-') && (c != ' '))
 					goto bad_server_command;
+				if (c == '-')
+					return FTPXY_JUNK_CONT;
 			} else
 				goto bad_server_command;
 		} else
@@ -926,21 +932,28 @@
 			       "ippr_ftp_server_valid",
 			       ftps->ftps_junk, (int)len, (int)i,
 			       c, (int)len, (int)len, buf);
-		return 1;
+		if (ftps->ftps_junk == FTPXY_JUNK_CONT)
+			return FTPXY_JUNK_CONT;
+		return FTPXY_JUNK_BAD;
 	}
 search_eol:
 	for (; i; i--) {
 		pc = c;
 		c = *s++;
 		if ((pc == '\r') && (c == '\n')) {
-			ftps->ftps_cmds = cmd;
-			return 0;
+			if (cmd == -1) {
+				if (ftps->ftps_junk == FTPXY_JUNK_CONT)
+					return FTPXY_JUNK_CONT;
+			} else {
+				ftps->ftps_cmds = cmd;
+			}
+			return FTPXY_JUNK_OK;
 		}
 	}
 	if (ippr_ftp_debug > 3)
 		printf("ippr_ftp_server_valid:junk after cmd[%*.*s]\n",
 		       (int)len, (int)len, buf);
-	return 2;
+	return FTPXY_JUNK_EOL;
 }
 
 
@@ -977,7 +990,7 @@
 ftpinfo_t *ftp;
 int rv;
 {
-	int mlen, len, off, inc, i, sel, sel2, ok, ackoff, seqoff;
+	int mlen, len, off, inc, i, sel, sel2, ok, ackoff, seqoff, retry;
 	char *rptr, *wptr, *s;
 	u_32_t thseq, thack;
 	ap_session_t *aps;
@@ -1163,11 +1176,14 @@
 
 	while (mlen > 0) {
 		len = MIN(mlen, sizeof(f->ftps_buf) - (wptr - rptr));
+		if (len == 0)
+			break;
 		COPYDATA(m, off, len, wptr);
 		mlen -= len;
 		off += len;
 		wptr += len;
 
+whilemore:
 		if (ippr_ftp_debug > 3)
 			printf("%s:len %d/%d off %d wptr %lx junk %d [%*.*s]\n",
 			       "ippr_ftp_process",
@@ -1175,7 +1191,7 @@
 			       len, len, rptr);
 
 		f->ftps_wptr = wptr;
-		if (f->ftps_junk != 0) {
+		if (f->ftps_junk != FTPXY_JUNK_OK) {
 			i = f->ftps_junk;
 			f->ftps_junk = ippr_ftp_valid(ftp, rv, rptr,
 						      wptr - rptr);
@@ -1184,7 +1200,7 @@
 				printf("%s:junk %d -> %d\n",
 				       "ippr_ftp_process", i, f->ftps_junk);
 
-			if (f->ftps_junk != 0) {
+			if (f->ftps_junk == FTPXY_JUNK_BAD) {
 				if (wptr - rptr == sizeof(f->ftps_buf)) {
 					if (ippr_ftp_debug > 4)
 						printf("%s:full buffer\n",
@@ -1193,19 +1209,12 @@
 					f->ftps_wptr = f->ftps_buf;
 					rptr = f->ftps_rptr;
 					wptr = f->ftps_wptr;
-					/*
-					 * Because we throw away data here that
-					 * we would otherwise parse, set the
-					 * junk flag to indicate just ignore
-					 * any data upto the next CRLF.
-					 */
-					f->ftps_junk = 1;
 					continue;
 				}
 			}
 		}
 
-		while ((f->ftps_junk == 0) && (wptr > rptr)) {
+		while ((f->ftps_junk == FTPXY_JUNK_OK) && (wptr > rptr)) {
 			len = wptr - rptr;
 			f->ftps_junk = ippr_ftp_valid(ftp, rv, rptr, len);
 
@@ -1217,7 +1226,7 @@
 				printf("buf [%*.*s]\n", len, len, rptr);
 			}
 
-			if (f->ftps_junk == 0) {
+			if (f->ftps_junk == FTPXY_JUNK_OK) {
 				f->ftps_rptr = rptr;
 				if (rv)
 					inc += ippr_ftp_server(fin, ip, nat,
@@ -1234,7 +1243,7 @@
 		 * Off to a bad start so lets just forget about using the
 		 * ftp proxy for this connection.
 		 */
-		if ((f->ftps_cmds == 0) && (f->ftps_junk == 1)) {
+		if ((f->ftps_cmds == 0) && (f->ftps_junk == FTPXY_JUNK_BAD)) {
 			/* f->ftps_seq[1] += inc; */
 
 			if (ippr_ftp_debug > 1)
@@ -1243,12 +1252,15 @@
 			return APR_ERR(2);
 		}
 
-		if ((f->ftps_junk != 0) && (rptr < wptr)) {
+		retry = 0;
+		if ((f->ftps_junk != FTPXY_JUNK_OK) && (rptr < wptr)) {
 			for (s = rptr; s < wptr; s++) {
 				if ((*s == '\r') && (s + 1 < wptr) &&
 				    (*(s + 1) == '\n')) {
 					rptr = s + 2;
-					f->ftps_junk = 0;
+					retry = 1;
+					if (f->ftps_junk != FTPXY_JUNK_CONT)
+						f->ftps_junk = FTPXY_JUNK_OK;
 					break;
 				}
 			}
@@ -1264,13 +1276,15 @@
 			 * current state.
 			 */
 			if (rptr > f->ftps_buf) {
-				bcopy(rptr, f->ftps_buf, len);
+				bcopy(rptr, f->ftps_buf, wptr - rptr);
 				wptr -= rptr - f->ftps_buf;
 				rptr = f->ftps_buf;
 			}
 		}
 		f->ftps_rptr = rptr;
 		f->ftps_wptr = wptr;
+		if (retry)
+			goto whilemore;
 	}
 
 	/* f->ftps_seq[1] += inc; */
diff -ur sys.orig/contrib/ipfilter/netinet/ip_htable.c sys/contrib/ipfilter/netinet/ip_htable.c
--- sys.orig/contrib/ipfilter/netinet/ip_htable.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_htable.c	2011-04-27 13:03:01.000000000 +0200
@@ -529,6 +529,12 @@
 
 	READ_ENTER(&ip_poolrw);
 
+	/*
+	 * Get "previous" entry from the token and find the next entry.
+	 *
+	 * If we found an entry, add a reference to it and update the token.
+	 * Otherwise, zero out data to be returned and NULL out token.
+	 */
 	switch (ilp->ili_otype)
 	{
 	case IPFLOOKUPITER_LIST :
@@ -571,37 +577,52 @@
 			token->ipt_data = NULL;
 		}
 		break;
+
 	default :
 		err = EINVAL;
 		break;
 	}
 
+	/*
+	 * Now that we have ref, it's save to give up lock.
+	 */
 	RWLOCK_EXIT(&ip_poolrw);
 	if (err != 0)
 		return err;
 
+	/*
+	 * Copy out data and clean up references and token as needed.
+	 */
 	switch (ilp->ili_otype)
 	{
 	case IPFLOOKUPITER_LIST :
-		if (iph != NULL) {
-			WRITE_ENTER(&ip_poolrw);
-			fr_derefhtable(iph);
-			RWLOCK_EXIT(&ip_poolrw);
-		}
 		err = COPYOUT(nextiph, ilp->ili_data, sizeof(*nextiph));
 		if (err != 0)
 			err = EFAULT;
+		if (token->ipt_data != NULL) {
+			if (iph != NULL) {
+				WRITE_ENTER(&ip_poolrw);
+				fr_derefhtable(iph);
+				RWLOCK_EXIT(&ip_poolrw);
+			}
+			if (nextiph->iph_next == NULL)
+				token->ipt_data = NULL;
+		}
 		break;
 
 	case IPFLOOKUPITER_NODE :
-		if (node != NULL) {
-			WRITE_ENTER(&ip_poolrw);
-			fr_derefhtent(node);
-			RWLOCK_EXIT(&ip_poolrw);
-		}
 		err = COPYOUT(nextnode, ilp->ili_data, sizeof(*nextnode));
 		if (err != 0)
 			err = EFAULT;
+		if (token->ipt_data != NULL) {
+			if (node != NULL) {
+				WRITE_ENTER(&ip_poolrw);
+				fr_derefhtent(node);
+				RWLOCK_EXIT(&ip_poolrw);
+			}
+			if (nextnode->ipe_next == NULL)
+				token->ipt_data = NULL;
+		}
 		break;
 	}
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_ipsec_pxy.c sys/contrib/ipfilter/netinet/ip_ipsec_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_ipsec_pxy.c	2007-06-04 04:49:45.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_ipsec_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -143,8 +143,6 @@
 	ipn->in_p = IPPROTO_ESP;
 
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_fi.fi_p = IPPROTO_ESP;
 	fi.fin_fr = &ipsecfr;
 	fi.fin_data[0] = 0;
@@ -166,18 +164,20 @@
 	if ((ipsec->ipsc_rcookie[0]|ipsec->ipsc_rcookie[1]) != 0)
 		ipsec->ipsc_rckset = 1;
 
+	MUTEX_ENTER(&ipf_nat_new);
 	ipsec->ipsc_nat = nat_new(&fi, ipn, &ipsec->ipsc_nat,
 				  NAT_SLAVE|SI_WILDP, NAT_OUTBOUND);
+	MUTEX_EXIT(&ipf_nat_new);
 	if (ipsec->ipsc_nat != NULL) {
 		(void) nat_proto(&fi, ipsec->ipsc_nat, 0);
-		nat_update(&fi, ipsec->ipsc_nat, ipn);
+		MUTEX_ENTER(&ipsec->ipsc_nat->nat_lock);
+		nat_update(&fi, ipsec->ipsc_nat);
+		MUTEX_EXIT(&ipsec->ipsc_nat->nat_lock);
 
 		fi.fin_data[0] = 0;
 		fi.fin_data[1] = 0;
 		ipsec->ipsc_state = fr_addstate(&fi, &ipsec->ipsc_state,
 						SI_WILDP);
-		if (fi.fin_state != NULL)
-			fr_statederef((ipstate_t **)&fi.fin_state);
 	}
 	ip->ip_p = p & 0xff;
 	return 0;
@@ -212,8 +212,6 @@
 
 		if ((ipsec->ipsc_nat == NULL) || (ipsec->ipsc_state == NULL)) {
 			bcopy((char *)fin, (char *)&fi, sizeof(fi));
-			fi.fin_state = NULL;
-			fi.fin_nat = NULL;
 			fi.fin_fi.fi_p = IPPROTO_ESP;
 			fi.fin_fr = &ipsecfr;
 			fi.fin_data[0] = 0;
@@ -229,14 +227,17 @@
 		if (ipsec->ipsc_nat != NULL)
 			fr_queueback(&ipsec->ipsc_nat->nat_tqe);
 		else {
+			MUTEX_ENTER(&ipf_nat_new);
 			ipsec->ipsc_nat = nat_new(&fi, &ipsec->ipsc_rule,
 						  &ipsec->ipsc_nat,
 						  NAT_SLAVE|SI_WILDP,
 						  nat->nat_dir);
+			MUTEX_EXIT(&ipf_nat_new);
 			if (ipsec->ipsc_nat != NULL) {
 				(void) nat_proto(&fi, ipsec->ipsc_nat, 0);
-				nat_update(&fi, ipsec->ipsc_nat,
-					   &ipsec->ipsc_rule);
+				MUTEX_ENTER(&ipsec->ipsc_nat->nat_lock);
+				nat_update(&fi, ipsec->ipsc_nat);
+				MUTEX_EXIT(&ipsec->ipsc_nat->nat_lock);
 			}
 		}
 
@@ -255,8 +256,6 @@
 			ipsec->ipsc_state = fr_addstate(&fi,
 							&ipsec->ipsc_state,
 							SI_WILDP);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 		ip->ip_p = p;
 	}
diff -ur sys.orig/contrib/ipfilter/netinet/ip_irc_pxy.c sys/contrib/ipfilter/netinet/ip_irc_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_irc_pxy.c	2007-06-04 04:49:45.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_irc_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -397,8 +397,6 @@
 		tcp2->th_win = htons(8192);
 		tcp2->th_sport = sp;
 		tcp2->th_dport = 0; /* XXX - don't specify remote port */
-		fi.fin_state = NULL;
-		fi.fin_nat = NULL;
 		fi.fin_data[0] = ntohs(sp);
 		fi.fin_data[1] = 0;
 		fi.fin_dp = (char *)tcp2;
@@ -407,15 +405,17 @@
 		fi.fin_plen = fi.fin_hlen + sizeof(*tcp2);
 		swip = ip->ip_src;
 		ip->ip_src = nat->nat_inip;
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL,
 			       NAT_SLAVE|IPN_TCP|SI_W_DPORT, NAT_OUTBOUND);
+		MUTEX_EXIT(&ipf_nat_new);
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, 0);
-			nat_update(&fi, nat2, nat2->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 
 			(void) fr_addstate(&fi, NULL, SI_W_DPORT);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 		ip->ip_src = swip;
 	}
diff -ur sys.orig/contrib/ipfilter/netinet/ip_log.c sys/contrib/ipfilter/netinet/ip_log.c
--- sys.orig/contrib/ipfilter/netinet/ip_log.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_log.c	2011-04-27 13:03:01.000000000 +0200
@@ -104,7 +101,6 @@
 #if __FreeBSD_version >= 300000
 # include <net/if_var.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #ifdef __sgi
 # include <sys/ddi.h>
@@ -149,7 +145,7 @@
 #  include	<sys/kthread_iface.h>
 #  define	READ_COLLISION	0x001
 
-iplog_select_t	iplog_ss[IPL_LOGMAX+1];
+iplog_select_t	iplog_ss[IPL_LOGSIZE];
 
 extern int selwait;
 # endif /* IPL_SELECT */
@@ -292,7 +288,7 @@
 			struct icmp *icmp;
 
 			icmp = (struct icmp *)fin->fin_dp;
-	
+
 			/*
 			 * For ICMP, if the packet is an error packet, also
 			 * include the information about the packet which
@@ -440,27 +436,6 @@
 	SPL_INT(s);
 
 	/*
-	 * Check to see if this log record has a CRC which matches the last
-	 * record logged.  If it does, just up the count on the previous one
-	 * rather than create a new one.
-	 */
-	if (ipl_suppress) {
-		MUTEX_ENTER(&ipl_mutex);
-		if ((fin != NULL) && (fin->fin_off == 0)) {
-			if ((ipll[dev] != NULL) &&
-			    bcmp((char *)fin, (char *)&iplcrc[dev],
-				 FI_LCSIZE) == 0) {
-				ipll[dev]->ipl_count++;
-				MUTEX_EXIT(&ipl_mutex);
-				return 0;
-			}
-			bcopy((char *)fin, (char *)&iplcrc[dev], FI_LCSIZE);
-		} else
-			bzero((char *)&iplcrc[dev], FI_CSIZE);
-		MUTEX_EXIT(&ipl_mutex);
-	}
-
-	/*
 	 * Get the total amount of data to be logged.
 	 */
 	for (i = 0, len = sizeof(iplog_t); i < cnt; i++)
@@ -470,25 +445,12 @@
 	 * check that we have space to record this information and can
 	 * allocate that much.
 	 */
+	if ((iplused[dev] + len) > ipl_logsize)
+		return -1;
+
 	KMALLOCS(buf, u_char *, len);
 	if (buf == NULL)
 		return -1;
-	SPL_NET(s);
-	MUTEX_ENTER(&ipl_mutex);
-	if ((iplused[dev] + len) > ipl_logsize) {
-		MUTEX_EXIT(&ipl_mutex);
-		SPL_X(s);
-		KFREES(buf, len);
-		return -1;
-	}
-	iplused[dev] += len;
-	MUTEX_EXIT(&ipl_mutex);
-	SPL_X(s);
-
-	/*
-	 * advance the log pointer to the next empty record and deduct the
-	 * amount of space we're going to use.
-	 */
 	ipl = (iplog_t *)buf;
 	ipl->ipl_magic = ipl_magic[dev];
 	ipl->ipl_count = 1;
@@ -513,11 +475,38 @@
 		}
 		ptr += itemsz[i];
 	}
+
 	SPL_NET(s);
 	MUTEX_ENTER(&ipl_mutex);
+	/*
+	 * Check to see if this log record has a CRC which matches the last
+	 * record logged.  If it does, just up the count on the previous one
+	 * rather than create a new one.
+	 */
+	if (ipl_suppress) {
+		if ((fin != NULL) && (fin->fin_off == 0)) {
+			if ((ipll[dev] != NULL) &&
+			    bcmp((char *)fin, (char *)&iplcrc[dev],
+				 FI_LCSIZE) == 0) {
+				ipll[dev]->ipl_count++;
+				MUTEX_EXIT(&ipl_mutex);
+				SPL_X(s);
+				KFREES(buf, len);
+				return 0;
+			}
+			bcopy((char *)fin, (char *)&iplcrc[dev], FI_LCSIZE);
+		} else
+			bzero((char *)&iplcrc[dev], FI_CSIZE);
+	}
+
+	/*
+	 * advance the log pointer to the next empty record and deduct the
+	 * amount of space we're going to use.
+	 */
 	ipll[dev] = ipl;
 	*iplh[dev] = ipl;
 	iplh[dev] = &ipl->ipl_next;
+	iplused[dev] += len;
 
 	/*
 	 * Now that the log record has been completed and added to the queue,
@@ -619,7 +608,8 @@
 # endif /* SOLARIS */
 	}
 
-# if (BSD >= 199101) || defined(__FreeBSD__) || defined(__osf__)
+# if (defined(BSD) && (BSD >= 199101)) || defined(__FreeBSD__) || \
+     defined(__osf__)
 	uio->uio_rw = UIO_READ;
 # endif
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_lookup.c sys/contrib/ipfilter/netinet/ip_lookup.c
--- sys.orig/contrib/ipfilter/netinet/ip_lookup.c	2007-10-18 23:42:34.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_lookup.c	2011-04-27 13:03:01.000000000 +0200
@@ -583,7 +583,7 @@
 	int err;
 	SPL_INT(s);
 
-	err = fr_inobj(data, &iter, IPFOBJ_LOOKUPITER);
+	err = fr_inobj(data, NULL, &iter, IPFOBJ_LOOKUPITER);
 	if (err != 0)
 		return err;
 
@@ -613,6 +613,9 @@
 		err = EINVAL;
 		break;
 	}
+
+	WRITE_ENTER(&ipf_tokens);
+	ipf_dereftoken(token);
 	RWLOCK_EXIT(&ipf_tokens);
 	SPL_X(s);
 
@@ -673,7 +676,7 @@
 	SPL_INT(s);
 
 	SPL_SCHED(s);
-	error = BCOPYIN(data, &key, sizeof(key)); 
+	error = BCOPYIN(data, &key, sizeof(key));
 	if (error == 0)
 		error = ipf_deltoken(key, uid, ctx);
 	SPL_X(s);
diff -ur sys.orig/contrib/ipfilter/netinet/ip_lookup.h sys/contrib/ipfilter/netinet/ip_lookup.h
--- sys.orig/contrib/ipfilter/netinet/ip_lookup.h	2007-10-18 23:42:51.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_lookup.h	2011-04-27 13:03:01.000000000 +0200
@@ -40,7 +40,7 @@
 	int	iplf_type;	/* IPLT_* */
 	int	iplf_unit;	/* IPL_LOG* */
 	u_int	iplf_arg;
-	size_t	iplf_count;
+	u_int	iplf_count;
 	char	iplf_name[FR_GROUPLEN];
 } iplookupflush_t;
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_nat.c sys/contrib/ipfilter/netinet/ip_nat.c
--- sys.orig/contrib/ipfilter/netinet/ip_nat.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_nat.c	2011-05-04 10:42:10.000000000 +0200
@@ -80,7 +80,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -104,6 +103,7 @@
 #include "netinet/ip_frag.h"
 #include "netinet/ip_state.h"
 #include "netinet/ip_proxy.h"
+#include "netinet/ipl.h"
 #ifdef	IPFILTER_SYNC
 #include "netinet/ip_sync.h"
 #endif
@@ -210,8 +209,8 @@
 static	nat_t	*fr_natclone __P((fr_info_t *, nat_t *));
 static	void	nat_mssclamp __P((tcphdr_t *, u_32_t, fr_info_t *, u_short *));
 static	int	nat_wildok __P((nat_t *, int, int, int, int));
-static	int	nat_getnext __P((ipftoken_t *, ipfgeniter_t *));
-static	int	nat_iterator __P((ipftoken_t *, ipfgeniter_t *));
+static	int	nat_getnext __P((ipftoken_t *, ipfgeniter_t *, ipfobj_t *));
+static	int	nat_iterator __P((ipftoken_t *, ipfgeniter_t *, ipfobj_t *));
 
 
 /* ------------------------------------------------------------------------ */
@@ -456,7 +455,7 @@
 	hv += src.s_addr;
 	hv += dst.s_addr;
 	hv %= HOSTMAP_SIZE;
-	for (hm = ipf_hm_maptable[hv]; hm; hm = hm->hm_next)
+	for (hm = ipf_hm_maptable[hv]; hm; hm = hm->hm_hnext)
 		if ((hm->hm_srcip.s_addr == src.s_addr) &&
 		    (hm->hm_dstip.s_addr == dst.s_addr) &&
 		    ((np == NULL) || (np == hm->hm_ipnat)) &&
@@ -653,7 +652,7 @@
 	ipnat_t natd;
 	SPL_INT(s);
 
-#if (BSD >= 199306) && defined(_KERNEL)
+#if defined(BSD) && (BSD >= 199306) && defined(_KERNEL)
 # if defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 399002000)
 	if ((mode & FWRITE) &&
 	     kauth_authorize_network(curlwp->l_cred, KAUTH_NETWORK_FIREWALL,
@@ -663,11 +662,11 @@
 	}
 # else
 #  if defined(__FreeBSD_version) && (__FreeBSD_version >= 500034)
-	if (securelevel_ge(curthread->td_ucred, 3) && (mode & FWRITE)) {
+        if (securelevel_ge(curthread->td_ucred, 3) && (mode & FWRITE)) {
 #  else
-	if ((securelevel >= 3) && (mode & FWRITE)) {
+        if ((securelevel >= 3) && (mode & FWRITE)) {
 #  endif
-		return EPERM;
+                return EPERM;
 	}
 # endif
 #endif
@@ -690,7 +689,7 @@
 			bcopy(data, (char *)&natd, sizeof(natd));
 			error = 0;
 		} else {
-			error = fr_inobj(data, &natd, IPFOBJ_IPNAT);
+			error = fr_inobj(data, NULL, &natd, IPFOBJ_IPNAT);
 		}
 	}
 
@@ -824,7 +823,7 @@
 	    {
 		natlookup_t nl;
 
-		error = fr_inobj(data, &nl, IPFOBJ_NATLOOKUP);
+		error = fr_inobj(data, NULL, &nl, IPFOBJ_NATLOOKUP);
 		if (error == 0) {
 			void *ptr;
 
@@ -911,15 +910,21 @@
 	    {
 		ipfgeniter_t iter;
 		ipftoken_t *token;
+		ipfobj_t obj;
 
 		SPL_SCHED(s);
-		error = fr_inobj(data, &iter, IPFOBJ_GENITER);
+		error = fr_inobj(data, &obj, &iter, IPFOBJ_GENITER);
 		if (error == 0) {
 			token = ipf_findtoken(iter.igi_type, uid, ctx);
 			if (token != NULL) {
-				error  = nat_iterator(token, &iter);
+				error = nat_iterator(token, &iter, &obj);
+				WRITE_ENTER(&ipf_tokens);
+				if (token->ipt_data == NULL)
+					ipf_freetoken(token);
+				else
+					ipf_dereftoken(token);
+				RWLOCK_EXIT(&ipf_tokens);
 			}
-			RWLOCK_EXIT(&ipf_tokens);
 		}
 		SPL_X(s);
 		break;
@@ -1283,7 +1288,7 @@
 	nat_save_t *ipn, ipns;
 	nat_t *n, *nat;
 
-	error = fr_inobj(data, &ipns, IPFOBJ_NATSAVE);
+	error = fr_inobj(data, NULL, &ipns, IPFOBJ_NATSAVE);
 	if (error != 0)
 		return error;
 
@@ -1410,7 +1415,7 @@
 	ipnat_t *in;
 	int error;
 
-	error = fr_inobj(data, &ipn, IPFOBJ_NATSAVE);
+	error = fr_inobj(data, NULL, &ipn, IPFOBJ_NATSAVE);
 	if (error != 0)
 		return error;
 
@@ -1491,7 +1496,7 @@
 	 * For NAT_OUTBOUND, we're lookup for a duplicate MAP entry.  To do
 	 * this, we check to see if the inbound combination of addresses and
 	 * ports is already known.  Similar logic is applied for NAT_INBOUND.
-	 * 
+	 *
 	 */
 	bzero((char *)&fin, sizeof(fin));
 	fin.fin_p = nat->nat_p;
@@ -1513,7 +1518,7 @@
 		}
 	} else if (nat->nat_dir == NAT_INBOUND) {
 		fin.fin_ifp = nat->nat_ifps[0];
-		fin.fin_data[0] = ntohs(nat->nat_outport);
+		fin.fin_data[0] = ntohs(nat->nat_inport);
 		fin.fin_data[1] = ntohs(nat->nat_oport);
 		if (getlock) {
 			READ_ENTER(&ipf_nat);
@@ -1831,7 +1836,6 @@
 		j++;
 	}
 
-	nat_stats.ns_inuse = 0;
 	return j;
 }
 
@@ -2128,8 +2132,8 @@
 		((icmphdr_t *)fin->fin_dp)->icmp_id = port;
 		nat->nat_inport = port;
 		nat->nat_outport = port;
-	} else if (fin->fin_p == IPPROTO_GRE) {
 #if 0
+	} else if (fin->fin_p == IPPROTO_GRE) {
 		nat->nat_gre.gs_flags = ((grehdr_t *)fin->fin_dp)->gr_flags;
 		if (GRE_REV(nat->nat_gre.gs_flags) == 1) {
 			nat->nat_oport = 0;/*fin->fin_data[1];*/
@@ -2320,8 +2324,8 @@
 		((icmphdr_t *)fin->fin_dp)->icmp_id = nport;
 		nat->nat_inport = nport;
 		nat->nat_outport = nport;
-	} else if (fin->fin_p == IPPROTO_GRE) {
 #if 0
+	} else if (fin->fin_p == IPPROTO_GRE) {
 		nat->nat_gre.gs_flags = ((grehdr_t *)fin->fin_dp)->gr_flags;
 		if (GRE_REV(nat->nat_gre.gs_flags) == 1) {
 			nat->nat_call[0] = fin->fin_data[0];
@@ -2438,10 +2442,6 @@
 	nat->nat_flags = flags;
 	nat->nat_redir = np->in_redir;
 
-	if ((flags & NAT_SLAVE) == 0) {
-		MUTEX_ENTER(&ipf_nat_new);
-	}
-
 	/*
 	 * Search the current table for a match.
 	 */
@@ -2555,9 +2555,8 @@
 	KFREE(nat);
 	nat = NULL;
 done:
-	if ((flags & NAT_SLAVE) == 0) {
-		MUTEX_EXIT(&ipf_nat_new);
-	}
+	if (nat != NULL && np != NULL)
+		np->in_hits++;
 	return nat;
 }
 
@@ -2606,7 +2605,7 @@
 	nat->nat_ptr = np;
 	nat->nat_p = fin->fin_p;
 	nat->nat_mssclamp = np->in_mssclamp;
-	if (nat->nat_p == IPPROTO_TCP)
+	if (nat->nat_flags & IPN_TCP)
 		nat->nat_seqnext[0] = ntohl(tcp->th_seq);
 
 	if ((np->in_apr != NULL) && ((ni->nai_flags & NAT_SLAVE) == 0))
@@ -2683,10 +2682,6 @@
 
 	nat->nat_rev = rev;
 	nat->nat_ref = 1;
-	nat->nat_bytes[0] = 0;
-	nat->nat_pkts[0] = 0;
-	nat->nat_bytes[1] = 0;
-	nat->nat_pkts[1] = 0;
 
 	nat->nat_ifnames[0][LIFNAMSIZ - 1] = '\0';
 	nat->nat_ifps[0] = fr_resolvenic(nat->nat_ifnames[0], 4);
@@ -2707,25 +2702,29 @@
 		nat_instances->nat_pnext = &nat->nat_next;
 	nat_instances = nat;
 
+	/*
+	 * Bump this before the hash table inserts.
+	 */
+	nat_stats.ns_added++;
+
 	natp = &nat_table[0][hv1];
-	if (*natp)
-		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
 	nat->nat_phnext[0] = natp;
 	nat->nat_hnext[0] = *natp;
+	if (*natp)
+		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
 	*natp = nat;
 	nat_stats.ns_bucketlen[0][hv1]++;
 
 	natp = &nat_table[1][hv2];
-	if (*natp)
-		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
 	nat->nat_phnext[1] = natp;
 	nat->nat_hnext[1] = *natp;
+	if (*natp)
+		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
 	*natp = nat;
 	nat_stats.ns_bucketlen[1][hv2]++;
 
 	fr_setnatqueue(nat, rev);
 
-	nat_stats.ns_added++;
 	nat_stats.ns_inuse++;
 	return 0;
 }
@@ -2831,7 +2830,7 @@
 			return nat;
 		}
 	}
-		
+
 	if (flags & IPN_TCPUDP) {
 		minlen += 8;		/* + 64bits of data to get ports */
 		if (fin->fin_plen < ICMPERR_IPICMPHLEN + minlen)
@@ -3003,7 +3002,7 @@
 		 *
 		 * Since the port fields are part of the TCP/UDP checksum
 		 * of the offending IP packet, you need to adjust that checksum
-		 * as well... except that the change in the port numbers should 
+		 * as well... except that the change in the port numbers should
 		 * be offset by the checksum change.  However, the TCP/UDP
 		 * checksum will also need to change if there has been an
 		 * IP address change.
@@ -3186,8 +3185,7 @@
 		if (nat->nat_ifps[0] != NULL) {
 			if ((ifp != NULL) && (ifp != nat->nat_ifps[0]))
 				continue;
-		} else if (ifp != NULL)
-			nat->nat_ifps[0] = ifp;
+		}
 
 		nflags = nat->nat_flags;
 
@@ -3228,6 +3226,8 @@
 			if ((ipn != NULL) && (nat->nat_aps != NULL))
 				if (appr_match(fin, nat) != 0)
 					continue;
+			if ((nat->nat_ifps[0] == NULL) && (ifp != NULL))
+				nat->nat_ifps[0] = ifp;
 			return nat;
 		}
 	}
@@ -3257,8 +3257,7 @@
 		if (nat->nat_ifps[0] != NULL) {
 			if ((ifp != NULL) && (ifp != nat->nat_ifps[0]))
 				continue;
-		} else if (ifp != NULL)
-			nat->nat_ifps[0] = ifp;
+		}
 
 		if (nat->nat_p != fin->fin_p)
 			continue;
@@ -3283,6 +3282,8 @@
 				nat_stats.ns_wilds--;
 				MUTEX_EXIT(&ipf_nat_new);
 			}
+			if ((nat->nat_ifps[0] == NULL) && (ifp != NULL))
+				nat->nat_ifps[0] = ifp;
 			nat->nat_oport = sport;
 			nat->nat_outport = dport;
 			nat->nat_flags &= ~(SI_W_DPORT|SI_W_SPORT);
@@ -3428,8 +3429,7 @@
 		if (nat->nat_ifps[1] != NULL) {
 			if ((ifp != NULL) && (ifp != nat->nat_ifps[1]))
 				continue;
-		} else if (ifp != NULL)
-			nat->nat_ifps[1] = ifp;
+		}
 
 		nflags = nat->nat_flags;
 
@@ -3460,6 +3460,8 @@
 			if ((ipn != NULL) && (nat->nat_aps != NULL))
 				if (appr_match(fin, nat) != 0)
 					continue;
+			if ((nat->nat_ifps[1] == NULL) && (ifp != NULL))
+				nat->nat_ifps[1] = ifp;
 			return nat;
 		}
 	}
@@ -3489,8 +3491,7 @@
 		if (nat->nat_ifps[1] != NULL) {
 			if ((ifp != NULL) && (ifp != nat->nat_ifps[1]))
 				continue;
-		} else if (ifp != NULL)
-			nat->nat_ifps[1] = ifp;
+		}
 
 		if (nat->nat_p != fin->fin_p)
 			continue;
@@ -3515,6 +3516,8 @@
 				nat_stats.ns_wilds--;
 				MUTEX_EXIT(&ipf_nat_new);
 			}
+			if ((nat->nat_ifps[1] == NULL) && (ifp != NULL))
+				nat->nat_ifps[1] = ifp;
 			nat->nat_inport = sport;
 			nat->nat_oport = dport;
 			if (nat->nat_outport == 0)
@@ -3670,19 +3673,21 @@
 /* Returns:     Nil                                                         */
 /* Parameters:  nat(I)    - pointer to NAT structure                        */
 /*              np(I)     - pointer to NAT rule                             */
+/* Locks:       nat_lock                                                    */
 /*                                                                          */
 /* Updates the lifetime of a NAT table entry for non-TCP packets.  Must be  */
 /* called with fin_rev updated - i.e. after calling nat_proto().            */
+/*                                                                          */
+/* This must be called *after* nat_proto() because we need fin_rev set.     */
 /* ------------------------------------------------------------------------ */
-void nat_update(fin, nat, np)
+void nat_update(fin, nat)
 fr_info_t *fin;
 nat_t *nat;
-ipnat_t *np;
 {
 	ipftq_t *ifq, *ifq2;
 	ipftqent_t *tqe;
+	ipnat_t *np = nat->nat_ptr;
 
-	MUTEX_ENTER(&nat->nat_lock);
 	tqe = &nat->nat_tqe;
 	ifq = tqe->tqe_ifq;
 
@@ -3730,7 +3735,6 @@
 
 		fr_movequeue(tqe, ifq, ifq2);
 	}
-	MUTEX_EXIT(&nat->nat_lock);
 }
 
 
@@ -3753,18 +3757,20 @@
 fr_info_t *fin;
 u_32_t *passp;
 {
+	ipnat_t *np = NULL, *npnext;
 	struct ifnet *ifp, *sifp;
 	icmphdr_t *icmp = NULL;
 	tcphdr_t *tcp = NULL;
 	int rval, natfailed;
-	ipnat_t *np = NULL;
 	u_int nflags = 0;
 	u_32_t ipa, iph;
 	int natadd = 1;
 	frentry_t *fr;
 	nat_t *nat;
 
-	if (nat_stats.ns_rules == 0 || fr_nat_lock != 0)
+	if (fr_nat_lock != 0)
+		return 0;
+	if (nat_stats.ns_rules == 0 && nat_instances == NULL)
 		return 0;
 
 	natfailed = 0;
@@ -3799,7 +3805,7 @@
 		default :
 			break;
 		}
-		
+
 		if ((nflags & IPN_TCPUDP))
 			tcp = fin->fin_dp;
 	}
@@ -3816,23 +3822,21 @@
 	else if ((nat = nat_outlookup(fin, nflags|NAT_SEARCH, (u_int)fin->fin_p,
 				      fin->fin_src, fin->fin_dst))) {
 		nflags = nat->nat_flags;
-	} else {
+	} else if (fin->fin_off == 0) {
 		u_32_t hv, msk, nmsk;
 
+		msk = 0xffffffff;
+		nmsk = nat_masks;
 		/*
 		 * If there is no current entry in the nat table for this IP#,
 		 * create one for it (if there is a matching rule).
 		 */
-		RWLOCK_EXIT(&ipf_nat);
-		msk = 0xffffffff;
-		nmsk = nat_masks;
-		WRITE_ENTER(&ipf_nat);
 maskloop:
 		iph = ipa & htonl(msk);
 		hv = NAT_HASH_FN(iph, 0, ipf_natrules_sz);
-		for (np = nat_rules[hv]; np; np = np->in_mnext)
-		{
-			if ((np->in_ifps[1] && (np->in_ifps[1] != ifp)))
+		for (np = nat_rules[hv]; np; np = npnext) {
+			npnext = np->in_mnext;
+			if (np->in_ifps[1] && (np->in_ifps[1] != ifp))
 				continue;
 			if (np->in_v != fin->fin_v)
 				continue;
@@ -3858,12 +3862,14 @@
 					continue;
 			}
 
-			if ((nat = nat_new(fin, np, NULL, nflags,
-					   NAT_OUTBOUND))) {
-				np->in_hits++;
+			MUTEX_ENTER(&ipf_nat_new);
+			nat = nat_new(fin, np, NULL, nflags, NAT_OUTBOUND);
+			MUTEX_EXIT(&ipf_nat_new);
+			if (nat != NULL) {
+				natfailed = 0;
 				break;
-			} else
-				natfailed = -1;
+			}
+			natfailed = -1;
 		}
 		if ((np == NULL) && (nmsk != 0)) {
 			while (nmsk) {
@@ -3877,17 +3883,17 @@
 				goto maskloop;
 			}
 		}
-		MUTEX_DOWNGRADE(&ipf_nat);
 	}
 
 	if (nat != NULL) {
 		rval = fr_natout(fin, nat, natadd, nflags);
 		if (rval == 1) {
 			MUTEX_ENTER(&nat->nat_lock);
-			nat->nat_ref++;
+			nat_update(fin, nat);
+			nat->nat_bytes[1] += fin->fin_plen;
+			nat->nat_pkts[1]++;
+			fin->fin_pktnum = nat->nat_pkts[1];
 			MUTEX_EXIT(&nat->nat_lock);
-			nat->nat_touched = fr_ticks;
-			fin->fin_nat = nat;
 		}
 	} else
 		rval = natfailed;
@@ -3920,24 +3926,17 @@
 u_32_t nflags;
 {
 	icmphdr_t *icmp;
-	u_short *csump;
 	tcphdr_t *tcp;
 	ipnat_t *np;
 	int i;
 
 	tcp = NULL;
 	icmp = NULL;
-	csump = NULL;
 	np = nat->nat_ptr;
 
 	if ((natadd != 0) && (fin->fin_flx & FI_FRAG) && (np != NULL))
 		(void) fr_nat_newfrag(fin, 0, nat);
 
-	MUTEX_ENTER(&nat->nat_lock);
-	nat->nat_bytes[1] += fin->fin_plen;
-	nat->nat_pkts[1]++;
-	MUTEX_EXIT(&nat->nat_lock);
-
 	/*
 	 * Fix up checksums, not by recalculating them, but
 	 * simply computing adjustments.
@@ -3975,6 +3974,8 @@
 	}
 
 	if (!(fin->fin_flx & FI_SHORT) && (fin->fin_off == 0)) {
+		u_short *csump;
+
 		if ((nat->nat_outport != 0) && (nflags & IPN_TCPUDP)) {
 			tcp = fin->fin_dp;
 
@@ -3988,21 +3989,20 @@
 		}
 
 		csump = nat_proto(fin, nat, nflags);
+
+		/*
+		 * The above comments do not hold for layer 4 (or higher)
+		 * checksums...
+		 */
+		if (csump != NULL) {
+			if (nat->nat_dir == NAT_OUTBOUND)
+				fix_outcksum(fin, csump, nat->nat_sumd[1]);
+			else
+				fix_incksum(fin, csump, nat->nat_sumd[1]);
+		}
 	}
 
 	fin->fin_ip->ip_src = nat->nat_outip;
-
-	nat_update(fin, nat, np);
-
-	/*
-	 * The above comments do not hold for layer 4 (or higher) checksums...
-	 */
-	if (csump != NULL) {
-		if (nat->nat_dir == NAT_OUTBOUND)
-			fix_outcksum(fin, csump, nat->nat_sumd[1]);
-		else
-			fix_incksum(fin, csump, nat->nat_sumd[1]);
-	}
 #ifdef	IPFILTER_SYNC
 	ipfsync_update(SMC_NAT, fin, nat->nat_sync);
 #endif
@@ -4047,6 +4047,7 @@
 fr_info_t *fin;
 u_32_t *passp;
 {
+	ipnat_t *np, *npnext;
 	u_int nflags, natadd;
 	int rval, natfailed;
 	struct ifnet *ifp;
@@ -4054,11 +4055,12 @@
 	icmphdr_t *icmp;
 	tcphdr_t *tcp;
 	u_short dport;
-	ipnat_t *np;
 	nat_t *nat;
 	u_32_t iph;
 
-	if (nat_stats.ns_rules == 0 || fr_nat_lock != 0)
+	if (fr_nat_lock != 0)
+		return 0;
+	if (nat_stats.ns_rules == 0 && nat_instances == NULL)
 		return 0;
 
 	tcp = NULL;
@@ -4087,12 +4089,12 @@
 			 */
 			if (nat_icmpquerytype4(icmp->icmp_type)) {
 				nflags = IPN_ICMPQUERY;
-				dport = icmp->icmp_id;	
+				dport = icmp->icmp_id;
 			} break;
 		default :
 			break;
 		}
-		
+
 		if ((nflags & IPN_TCPUDP)) {
 			tcp = fin->fin_dp;
 			dport = tcp->th_dport;
@@ -4106,18 +4108,17 @@
 	if (((fin->fin_flx & FI_ICMPERR) != 0) &&
 	    (nat = nat_icmperror(fin, &nflags, NAT_INBOUND)))
 		/*EMPTY*/;
-	else if ((fin->fin_flx & FI_FRAG) && (nat = fr_nat_knownfrag(fin)))
+	else if ((fin->fin_flx & FI_FRAG) &&
+		 (nat = fr_nat_knownfrag(fin)))
 		natadd = 0;
 	else if ((nat = nat_inlookup(fin, nflags|NAT_SEARCH, (u_int)fin->fin_p,
 				     fin->fin_src, in))) {
 		nflags = nat->nat_flags;
-	} else {
+	} else if (fin->fin_off == 0) {
 		u_32_t hv, msk, rmsk;
 
-		RWLOCK_EXIT(&ipf_nat);
-		rmsk = rdr_masks;
 		msk = 0xffffffff;
-		WRITE_ENTER(&ipf_nat);
+		rmsk = rdr_masks;
 		/*
 		 * If there is no current entry in the nat table for this IP#,
 		 * create one for it (if there is a matching rule).
@@ -4125,7 +4126,8 @@
 maskloop:
 		iph = in.s_addr & htonl(msk);
 		hv = NAT_HASH_FN(iph, 0, ipf_rdrrules_sz);
-		for (np = rdr_rules[hv]; np; np = np->in_rnext) {
+		for (np = rdr_rules[hv]; np; np = npnext) {
+			npnext = np->in_rnext;
 			if (np->in_ifps[0] && (np->in_ifps[0] != ifp))
 				continue;
 			if (np->in_v != fin->fin_v)
@@ -4152,12 +4154,24 @@
 				}
 			}
 
+			/*
+			 * If we've matched a round-robin rule but it has
+			 * moved in the list since we got it, start over as
+			 * this is now no longer correct.
+			 */
+			MUTEX_ENTER(&ipf_nat_new);
+			if ((npnext != np->in_rnext) &&
+			    (np->in_flags & IPN_ROUNDR)) {
+				MUTEX_EXIT(&ipf_nat_new);
+				goto maskloop;
+			}
 			nat = nat_new(fin, np, NULL, nflags, NAT_INBOUND);
+			MUTEX_EXIT(&ipf_nat_new);
 			if (nat != NULL) {
-				np->in_hits++;
+				natfailed = 0;
 				break;
-			} else
-				natfailed = -1;
+			}
+			natfailed = -1;
 		}
 
 		if ((np == NULL) && (rmsk != 0)) {
@@ -4172,16 +4186,17 @@
 				goto maskloop;
 			}
 		}
-		MUTEX_DOWNGRADE(&ipf_nat);
 	}
+
 	if (nat != NULL) {
 		rval = fr_natin(fin, nat, natadd, nflags);
 		if (rval == 1) {
 			MUTEX_ENTER(&nat->nat_lock);
-			nat->nat_ref++;
+			nat_update(fin, nat);
+			nat->nat_bytes[0] += fin->fin_plen;
+			nat->nat_pkts[0]++;
+			fin->fin_pktnum = nat->nat_pkts[0];
 			MUTEX_EXIT(&nat->nat_lock);
-			nat->nat_touched = fr_ticks;
-			fin->fin_nat = nat;
 		}
 	} else
 		rval = natfailed;
@@ -4215,13 +4230,11 @@
 u_32_t nflags;
 {
 	icmphdr_t *icmp;
-	u_short *csump;
 	tcphdr_t *tcp;
 	ipnat_t *np;
 	int i;
 
 	tcp = NULL;
-	csump = NULL;
 	np = nat->nat_ptr;
 	fin->fin_fr = nat->nat_fr;
 
@@ -4251,11 +4264,6 @@
 	ipfsync_update(SMC_NAT, fin, nat->nat_sync);
 #endif
 
-	MUTEX_ENTER(&nat->nat_lock);
-	nat->nat_bytes[0] += fin->fin_plen;
-	nat->nat_pkts[0]++;
-	MUTEX_EXIT(&nat->nat_lock);
-
 	fin->fin_ip->ip_dst = nat->nat_inip;
 	fin->fin_fi.fi_daddr = nat->nat_inip.s_addr;
 	if (nflags & IPN_TCPUDP)
@@ -4280,6 +4288,8 @@
 #endif
 
 	if (!(fin->fin_flx & FI_SHORT) && (fin->fin_off == 0)) {
+		u_short *csump;
+
 		if ((nat->nat_inport != 0) && (nflags & IPN_TCPUDP)) {
 			tcp->th_dport = nat->nat_inport;
 			fin->fin_data[1] = ntohs(nat->nat_inport);
@@ -4293,18 +4303,17 @@
 		}
 
 		csump = nat_proto(fin, nat, nflags);
-	}
 
-	nat_update(fin, nat, np);
-
-	/*
-	 * The above comments do not hold for layer 4 (or higher) checksums...
-	 */
-	if (csump != NULL) {
-		if (nat->nat_dir == NAT_OUTBOUND)
-			fix_incksum(fin, csump, nat->nat_sumd[0]);
-		else
-			fix_outcksum(fin, csump, nat->nat_sumd[0]);
+		/*
+		 * The above comments do not hold for layer 4 (or higher)
+		 * checksums...
+		 */
+		if (csump != NULL) {
+			if (nat->nat_dir == NAT_OUTBOUND)
+				fix_incksum(fin, csump, nat->nat_sumd[0]);
+			else
+				fix_outcksum(fin, csump, nat->nat_sumd[0]);
+		}
 	}
 	ATOMIC_INCL(nat_stats.ns_mapped[0]);
 	fin->fin_flx |= FI_NATED;
@@ -4627,10 +4636,10 @@
 	 * altough it seems silly to call a reply a query, this is exactly
 	 * as it is defined in the IPv4 specification
 	 */
-	
+
 	switch (icmptype)
 	{
-	
+
 	case ICMP_ECHOREPLY:
 	case ICMP_ECHO:
 	/* route aedvertisement/solliciation is currently unsupported: */
@@ -5054,15 +5063,13 @@
 /*              itp(I) - pointer to ipfgeniter_t structure                  */
 /*                                                                          */
 /* Fetch the next nat/ipnat structure pointer from the linked list and      */
-/* copy it out to the storage space pointed to by itp_data.  The next item  */
+/* copy it out to the storage space pointed to by itp.  The next item       */
 /* in the list to look at is put back in the ipftoken struture.             */
-/* If we call ipf_freetoken, the accompanying pointer is set to NULL because*/
-/* ipf_freetoken will call a deref function for us and we dont want to call */
-/* that twice (second time would be in the second switch statement below.   */
 /* ------------------------------------------------------------------------ */
-static int nat_getnext(t, itp)
+static int nat_getnext(t, itp, obj)
 ipftoken_t *t;
 ipfgeniter_t *itp;
+ipfobj_t *obj;
 {
 	hostmap_t *hm, *nexthm = NULL, zerohm;
 	ipnat_t *ipn, *nextipnat = NULL, zeroipn;
@@ -5070,12 +5077,14 @@
 	int error = 0, count;
 	char *dst;
 
-	count = itp->igi_nitems;
-	if (count < 1)
+	if (itp->igi_nitems < 1)
 		return ENOSPC;
 
 	READ_ENTER(&ipf_nat);
 
+	/*
+	 * Get "previous" entry from the token and find the next entry.
+	 */
 	switch (itp->igi_type)
 	{
 	case IPFGENITER_HOSTMAP :
@@ -5104,67 +5113,63 @@
 			nextnat = nat->nat_next;
 		}
 		break;
+
 	default :
 		RWLOCK_EXIT(&ipf_nat);
 		return EINVAL;
 	}
 
 	dst = itp->igi_data;
-	for (;;) {
+	for (count = itp->igi_nitems; count > 0; count--) {
+		/*
+		 * If we found an entry, add a reference and update the token.
+		 * Otherwise, zero out data to be returned and NULL out token.
+		 */
 		switch (itp->igi_type)
 		{
 		case IPFGENITER_HOSTMAP :
 			if (nexthm != NULL) {
-				if (count == 1) {
-					ATOMIC_INC32(nexthm->hm_ref);
-					t->ipt_data = nexthm;
-				}
+				ATOMIC_INC32(nexthm->hm_ref);
+				t->ipt_data = nexthm;
 			} else {
 				bzero(&zerohm, sizeof(zerohm));
 				nexthm = &zerohm;
-				count = 1;
 				t->ipt_data = NULL;
 			}
 			break;
 
 		case IPFGENITER_IPNAT :
 			if (nextipnat != NULL) {
-				if (count == 1) {
-					MUTEX_ENTER(&nextipnat->in_lock);
-					nextipnat->in_use++;
-					MUTEX_EXIT(&nextipnat->in_lock);
-					t->ipt_data = nextipnat;
-				}
+				ATOMIC_INC32(nextipnat->in_use);
+				t->ipt_data = nextipnat;
 			} else {
 				bzero(&zeroipn, sizeof(zeroipn));
 				nextipnat = &zeroipn;
-				count = 1;
 				t->ipt_data = NULL;
 			}
 			break;
 
 		case IPFGENITER_NAT :
 			if (nextnat != NULL) {
-				if (count == 1) {
-					MUTEX_ENTER(&nextnat->nat_lock);
-					nextnat->nat_ref++;
-					MUTEX_EXIT(&nextnat->nat_lock);
-					t->ipt_data = nextnat;
-				}
+				MUTEX_ENTER(&nextnat->nat_lock);
+				nextnat->nat_ref++;
+				MUTEX_EXIT(&nextnat->nat_lock);
+				t->ipt_data = nextnat;
 			} else {
 				bzero(&zeronat, sizeof(zeronat));
 				nextnat = &zeronat;
-				count = 1;
 				t->ipt_data = NULL;
 			}
 			break;
-		default :
-			break;
 		}
+
+		/*
+		 * Now that we have ref, it's save to give up lock.
+		 */
 		RWLOCK_EXIT(&ipf_nat);
 
 		/*
-		 * Copying out to user space needs to be done without the lock.
+		 * Copy out data and clean up references and token as needed.
 		 */
 		switch (itp->igi_type)
 		{
@@ -5172,74 +5177,71 @@
 			error = COPYOUT(nexthm, dst, sizeof(*nexthm));
 			if (error != 0)
 				error = EFAULT;
-			else
+			if (hm != NULL) {
+				WRITE_ENTER(&ipf_nat);
+				fr_hostmapdel(&hm);
+				RWLOCK_EXIT(&ipf_nat);
+			}
+			if (t->ipt_data != NULL) {
+				if (nexthm->hm_next == NULL) {
+					t->ipt_data = NULL;
+					break;
+				}
 				dst += sizeof(*nexthm);
+				hm = nexthm;
+				nexthm = nexthm->hm_next;
+			}
 			break;
 
 		case IPFGENITER_IPNAT :
-			error = COPYOUT(nextipnat, dst, sizeof(*nextipnat));
+			obj->ipfo_size = sizeof(ipnat_t);
+			obj->ipfo_ptr = dst;
+			obj->ipfo_type = IPFOBJ_IPNAT;
+			error = fr_outobjk(obj, nextipnat);
 			if (error != 0)
 				error = EFAULT;
-			else
+			if (ipn != NULL) {
+				WRITE_ENTER(&ipf_nat);
+				fr_ipnatderef(&ipn);
+				RWLOCK_EXIT(&ipf_nat);
+			}
+			if (t->ipt_data != NULL) {
+				if (nextipnat->in_next == NULL) {
+					t->ipt_data = NULL;
+					break;
+				}
 				dst += sizeof(*nextipnat);
+				ipn = nextipnat;
+				nextipnat = nextipnat->in_next;
+			}
 			break;
 
 		case IPFGENITER_NAT :
-			error = COPYOUT(nextnat, dst, sizeof(*nextnat));
+			obj->ipfo_size = sizeof(nat_t);
+			obj->ipfo_ptr = dst;
+			obj->ipfo_type = IPFOBJ_NAT;
+			error = fr_outobjk(obj, nextnat);
 			if (error != 0)
 				error = EFAULT;
-			else
+			if (nat != NULL) {
+				fr_natderef(&nat);
+			}
+			if (t->ipt_data != NULL) {
+				if (nextnat->nat_next == NULL) {
+					t->ipt_data = NULL;
+					break;
+				}
 				dst += sizeof(*nextnat);
+				nat = nextnat;
+				nextnat = nextnat->nat_next;
+			}
 			break;
 		}
 
 		if ((count == 1) || (error != 0))
 			break;
 
-		count--;
-
 		READ_ENTER(&ipf_nat);
-
-		/*
-		 * We need to have the lock again here to make sure that
-		 * using _next is consistent.
-		 */
-		switch (itp->igi_type)
-		{
-		case IPFGENITER_HOSTMAP :
-			nexthm = nexthm->hm_next;
-			break;
-		case IPFGENITER_IPNAT :
-			nextipnat = nextipnat->in_next;
-			break;
-		case IPFGENITER_NAT :
-			nextnat = nextnat->nat_next;
-			break;
-		}
-	}
-
-
-	switch (itp->igi_type)
-	{
-	case IPFGENITER_HOSTMAP :
-		if (hm != NULL) {
-			WRITE_ENTER(&ipf_nat);
-			fr_hostmapdel(&hm);
-			RWLOCK_EXIT(&ipf_nat);
-		}
-		break;
-	case IPFGENITER_IPNAT :
-		if (ipn != NULL) {
-			fr_ipnatderef(&ipn);
-		}
-		break;
-	case IPFGENITER_NAT :
-		if (nat != NULL) {
-			fr_natderef(&nat);
-		}
-		break;
-	default :
-		break;
 	}
 
 	return error;
@@ -5257,9 +5259,10 @@
 /* linked lists of NAT related information to go through: NAT rules, active */
 /* NAT mappings and the NAT fragment cache.                                 */
 /* ------------------------------------------------------------------------ */
-static int nat_iterator(token, itp)
+static int nat_iterator(token, itp, obj)
 ipftoken_t *token;
 ipfgeniter_t *itp;
+ipfobj_t *obj;
 {
 	int error;
 
@@ -5273,7 +5276,7 @@
 	case IPFGENITER_HOSTMAP :
 	case IPFGENITER_IPNAT :
 	case IPFGENITER_NAT :
-		error = nat_getnext(token, itp);
+		error = nat_getnext(token, itp, obj);
 		break;
 
 	case IPFGENITER_NATFRAG :
@@ -5394,11 +5397,11 @@
 			removed++;
 		}
 		break;
-	 
+
 	default :
 		if (which < 30)
 			break;
-	   
+
 		/*
 		 * Take a large arbitrary number to mean the number of seconds
 		 * for which which consider to be the maximum value we'll allow
@@ -5466,19 +5469,19 @@
 	ipftable_t table;
 	int error;
 
-	error = fr_inobj(data, &table, IPFOBJ_GTABLE);
+	error = fr_inobj(data, NULL, &table, IPFOBJ_GTABLE);
 	if (error != 0)
 		return error;
 
 	switch (table.ita_type)
 	{
 	case IPFTABLE_BUCKETS_NATIN :
-		error = COPYOUT(nat_stats.ns_bucketlen[0], table.ita_table, 
+		error = COPYOUT(nat_stats.ns_bucketlen[0], table.ita_table,
 				ipf_nattable_sz * sizeof(u_long));
 		break;
 
 	case IPFTABLE_BUCKETS_NATOUT :
-		error = COPYOUT(nat_stats.ns_bucketlen[1], table.ita_table, 
+		error = COPYOUT(nat_stats.ns_bucketlen[1], table.ita_table,
 				ipf_nattable_sz * sizeof(u_long));
 		break;
 
@@ -5491,3 +5494,56 @@
 	}
 	return error;
 }
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    nat_uncreate                                                */
+/* Returns:     Nil                                                         */
+/* Parameters:  fin(I) - pointer to packet information                      */
+/*                                                                          */
+/* This function is used to remove a NAT entry from the NAT table when we   */
+/* decide that the create was actually in error. It is thus assumed that    */
+/* fin_flx will have both FI_NATED and FI_NATNEW set. Because we're dealing */
+/* with the translated packet (not the original), we have to reverse the    */
+/* lookup. Although doing the lookup is expensive (relatively speaking), it */
+/* is not anticipated that this will be a frequent occurance for normal     */
+/* traffic patterns.                                                        */
+/* ------------------------------------------------------------------------ */
+void nat_uncreate(fin)
+fr_info_t *fin;
+{
+	int nflags;
+	nat_t *nat;
+
+	switch (fin->fin_p)
+	{
+	case IPPROTO_TCP :
+		nflags = IPN_TCP;
+		break;
+	case IPPROTO_UDP :
+		nflags = IPN_UDP;
+		break;
+	default :
+		nflags = 0;
+		break;
+	}
+
+	WRITE_ENTER(&ipf_nat);
+
+	if (fin->fin_out == 0) {
+		nat = nat_outlookup(fin, nflags, (u_int)fin->fin_p,
+				    fin->fin_dst, fin->fin_src);
+	} else {
+		nat = nat_inlookup(fin, nflags, (u_int)fin->fin_p,
+				   fin->fin_src, fin->fin_dst);
+	}
+
+	if (nat != NULL) {
+		nat_stats.ns_uncreate[fin->fin_out][0]++;
+		nat_delete(nat, NL_DESTROY);
+	} else {
+		nat_stats.ns_uncreate[fin->fin_out][1]++;
+	}
+
+	RWLOCK_EXIT(&ipf_nat);
+}
diff -ur sys.orig/contrib/ipfilter/netinet/ip_nat.h sys/contrib/ipfilter/netinet/ip_nat.h
--- sys.orig/contrib/ipfilter/netinet/ip_nat.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_nat.h	2011-04-27 13:03:01.000000000 +0200
@@ -367,6 +364,7 @@
 	u_long	*ns_bucketlen[2];
 	u_long	ns_ticks;
 	u_int	ns_orphans;
+	u_long	ns_uncreate[2][2];
 } natstat_t;
 
 typedef	struct	natlog {
@@ -454,6 +452,7 @@
 extern	nat_t	*nat_icmperror __P((fr_info_t *, u_int *, int));
 extern	void	nat_delete __P((struct nat *, int));
 extern	int	nat_insert __P((nat_t *, int));
+extern	void	nat_uncreate __P((fr_info_t *));
 
 extern	int	fr_checknatout __P((fr_info_t *, u_32_t *));
 extern	int	fr_natout __P((fr_info_t *, nat_t *, int, u_32_t));
@@ -467,7 +466,7 @@
 extern	void	fr_ipnatderef __P((ipnat_t **));
 extern	void	fr_natderef __P((nat_t **));
 extern	u_short	*nat_proto __P((fr_info_t *, nat_t *, u_int));
-extern	void	nat_update __P((fr_info_t *, nat_t *, ipnat_t *));
+extern	void	nat_update __P((fr_info_t *, nat_t *));
 extern	void	fr_setnatqueue __P((nat_t *, int));
 extern	void	fr_hostmapdel __P((hostmap_t **));
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_pool.c sys/contrib/ipfilter/netinet/ip_pool.c
--- sys.orig/contrib/ipfilter/netinet/ip_pool.c	2007-10-18 23:42:38.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_pool.c	2011-04-27 13:03:01.000000000 +0200
@@ -33,15 +35,10 @@
 # endif
 #endif
 #include <sys/time.h>
-#if !defined(linux)
-# include <sys/protosw.h>
-#endif
-#include <sys/socket.h>
-#if defined(_KERNEL) && (!defined(__SVR4) && !defined(__svr4__))
+#if defined(_KERNEL) && !defined(SOLARIS2)
 # include <sys/mbuf.h>
 #endif
 #if defined(__SVR4) || defined(__svr4__)
-# include <sys/filio.h>
 # include <sys/byteorder.h>
 # ifdef _KERNEL
 #  include <sys/dditypes.h>
@@ -61,6 +58,7 @@
 # include "radix_ipf_local.h"
 # define _RADIX_H_
 #endif
+#include <sys/socket.h>
 #include <net/if.h>
 #include <netinet/in.h>
 
@@ -97,23 +95,6 @@
 ip_pool_stat_t ipoolstat;
 ipfrwlock_t ip_poolrw;
 
-/*
- * Binary tree routines from Sedgewick and enhanced to do ranges of addresses.
- * NOTE: Insertion *MUST* be from greatest range to least for it to work!
- * These should be replaced, eventually, by something else - most notably a
- * interval searching method.  The important feature is to be able to find
- * the best match.
- *
- * So why not use a radix tree for this?  As the first line implies, it
- * has been written to work with a _range_ of addresses.  A range is not
- * necessarily a match with any given netmask so what we end up dealing
- * with is an interval tree.  Implementations of these are hard to find
- * and the one herein is far from bug free.
- *
- * Sigh, in the end I became convinced that the bugs the code contained did
- * not make it worthwhile not using radix trees.  For now the radix tree from
- * 4.4 BSD is used, but this is not viewed as a long term solution.
- */
 ip_pool_t *ip_pool_list[IPL_LOGSIZE] = { NULL, NULL, NULL, NULL,
 					 NULL, NULL, NULL, NULL };
 
@@ -247,7 +228,7 @@
 
 	bzero((char *)&ipoolstat, sizeof(ipoolstat));
 
-#if (!defined(_KERNEL) || (BSD < 199306))
+#if (!defined(_KERNEL) || !defined(BSD) || (BSD < 199306))
 	rn_init();
 #endif
 	return 0;
@@ -275,7 +256,7 @@
 		}
 	}
 
-#if (!defined(_KERNEL) || (BSD < 199306))
+#if (!defined(_KERNEL) || !defined(BSD) || (BSD < 199306))
 	rn_fini();
 #endif
 }
@@ -816,7 +797,7 @@
 /* Function:    ip_pool_getnext                                             */
 /* Returns:     void                                                        */
 /* Parameters:  token(I) - pointer to pool structure                        */
-/* Parameters:  ilp(IO)   - pointer to pool iterating structure             */
+/*              ilp(IO)  - pointer to pool iterating structure              */
 /*                                                                          */
 /* ------------------------------------------------------------------------ */
 int ip_pool_getnext(token, ilp)
@@ -835,6 +816,10 @@
 
 	READ_ENTER(&ip_poolrw);
 
+	/*
+	 * Get "previous" entry from token.  Find next entry to process,
+	 * and add reference to it and update the token.
+	 */
 	switch (ilp->ili_otype)
 	{
 	case IPFLOOKUPITER_LIST :
@@ -878,38 +863,53 @@
 			token->ipt_data = NULL;
 		}
 		break;
+
 	default :
 		err = EINVAL;
 		break;
 	}
 
+	/*
+	 * Now that we have ref, it's save to give up lock.
+	 */
 	RWLOCK_EXIT(&ip_poolrw);
 
 	if (err != 0)
 		return err;
 
+	/*
+	 * Copy out the data and update the references and token as needed.
+	 */
 	switch (ilp->ili_otype)
 	{
 	case IPFLOOKUPITER_LIST :
-		if (ipo != NULL) {
-			WRITE_ENTER(&ip_poolrw);
-			ip_pool_deref(ipo);
-			RWLOCK_EXIT(&ip_poolrw);
-		}
 		err = COPYOUT(nextipo, ilp->ili_data, sizeof(*nextipo));
 		if (err != 0)
 			err = EFAULT;
+		if (token->ipt_data != NULL) {
+			if (ipo != NULL) {
+				WRITE_ENTER(&ip_poolrw);
+				ip_pool_deref(ipo);
+				RWLOCK_EXIT(&ip_poolrw);
+			}
+			if (nextipo->ipo_next == NULL)
+				token->ipt_data = NULL;
+		}
 		break;
 
 	case IPFLOOKUPITER_NODE :
-		if (node != NULL) {
-			WRITE_ENTER(&ip_poolrw);
-			ip_pool_node_deref(node);
-			RWLOCK_EXIT(&ip_poolrw);
-		}
 		err = COPYOUT(nextnode, ilp->ili_data, sizeof(*nextnode));
 		if (err != 0)
 			err = EFAULT;
+		if (token->ipt_data != NULL) {
+			if (node != NULL) {
+				WRITE_ENTER(&ip_poolrw);
+				ip_pool_node_deref(node);
+				RWLOCK_EXIT(&ip_poolrw);
+			}
+			if (nextnode->ipn_next == NULL)
+				token->ipt_data = NULL;
+		}
 		break;
 	}
 
@@ -955,8 +955,8 @@
 }
 
 
-# if defined(_KERNEL) && ((BSD >= 198911) && !defined(__osf__) && \
-      !defined(__hpux) && !defined(__sgi))
+# if defined(_KERNEL) && (defined(BSD) && (BSD >= 198911) && \
+      !defined(__osf__) && !defined(__hpux) && !defined(__sgi))
 static int
 rn_freenode(struct radix_node *n, void *p)
 {
@@ -977,13 +977,16 @@
 {
 
 	RADIX_NODE_HEAD_LOCK(rnh);
+#  if defined(__NetBSD_Version__) && (__NetBSD_Version__ > 499002000)
+	rn_walktree(rnh, rn_freenode, rnh);
+#  else
 	(*rnh->rnh_walktree)(rnh, rn_freenode, rnh);
+#  endif
 
 	rnh->rnh_addaddr = NULL;
 	rnh->rnh_deladdr = NULL;
 	rnh->rnh_matchaddr = NULL;
 	rnh->rnh_lookup = NULL;
-	rnh->rnh_walktree = NULL;
 	RADIX_NODE_HEAD_UNLOCK(rnh);
 
 	Free(rnh);
diff -ur sys.orig/contrib/ipfilter/netinet/ip_pptp_pxy.c sys/contrib/ipfilter/netinet/ip_pptp_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_pptp_pxy.c	2007-06-04 04:49:55.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_pptp_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -165,8 +165,6 @@
 	if ((nat2 == NULL) || (pptp->pptp_state == NULL)) {
 		bcopy((char *)fin, (char *)&fi, sizeof(fi));
 		bzero((char *)&gre, sizeof(gre));
-		fi.fin_state = NULL;
-		fi.fin_nat = NULL;
 		fi.fin_fi.fi_p = IPPROTO_GRE;
 		fi.fin_fr = &pptpfr;
 		if ((nat->nat_dir == NAT_OUTBOUND && fin->fin_out) ||
@@ -198,12 +196,16 @@
 	if (nat2 != NULL)
 		fr_queueback(&nat2->nat_tqe);
 	else {
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, &pptp->pptp_rule, &pptp->pptp_nat,
 			       NAT_SLAVE, nat->nat_dir);
+		MUTEX_EXIT(&ipf_nat_new);
 		pptp->pptp_nat = nat2;
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, 0);
-			nat_update(&fi, nat2, nat2->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 		}
 	}
 
@@ -222,8 +224,6 @@
 		fi.fin_ifp = NULL;
 		pptp->pptp_state = fr_addstate(&fi, &pptp->pptp_state,
 					       0);
-		if (fi.fin_state != NULL)
-			fr_statederef((ipstate_t **)&fi.fin_state);
 	}
 	ip->ip_p = p;
 	return;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_proxy.c sys/contrib/ipfilter/netinet/ip_proxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_proxy.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_proxy.c	2011-04-27 14:12:12.000000000 +0200
@@ -70,7 +68,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -90,6 +87,8 @@
 # include <sys/malloc.h>
 #endif
 
+/* END OF INCLUDES */
+
 #include "netinet/ip_ftp_pxy.c"
 #include "netinet/ip_rcmd_pxy.c"
 # include "netinet/ip_pptp_pxy.c"
diff -ur sys.orig/contrib/ipfilter/netinet/ip_proxy.h sys/contrib/ipfilter/netinet/ip_proxy.h
--- sys.orig/contrib/ipfilter/netinet/ip_proxy.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_proxy.h	2011-04-27 13:03:01.000000000 +0200
@@ -143,7 +140,7 @@
  * This is the scratch buffer size used to hold strings from the TCP stream
  * that we may want to parse.  It's an arbitrary size, really, but it must
  * be at least as large as IPF_FTPBUFSZ.
- */ 
+ */
 #define	FTP_BUFSZ	120
 
 /*
diff -ur sys.orig/contrib/ipfilter/netinet/ip_raudio_pxy.c sys/contrib/ipfilter/netinet/ip_raudio_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_raudio_pxy.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_raudio_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -278,8 +275,6 @@
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
 	bzero((char *)tcp2, sizeof(*tcp2));
 	TCP_OFF_A(tcp2, 5);
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_flx |= FI_IGNORE;
 	fi.fin_dp = (char *)tcp2;
 	fi.fin_fr = &raudiofr;
@@ -298,16 +293,18 @@
 		fi.fin_data[0] = dp;
 		fi.fin_data[1] = sp;
 		fi.fin_out = 0;
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL,
 			       NAT_SLAVE|IPN_UDP | (sp ? 0 : SI_W_SPORT),
 			       NAT_OUTBOUND);
+		MUTEX_EXIT(&ipf_nat_new);
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, IPN_UDP);
-			nat_update(&fi, nat2, nat2->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 
 			(void) fr_addstate(&fi, NULL, (sp ? 0 : SI_W_SPORT));
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 	}
 
@@ -318,16 +315,18 @@
 		fi.fin_data[0] = sp;
 		fi.fin_data[1] = 0;
 		fi.fin_out = 1;
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL,
 			       NAT_SLAVE|IPN_UDP|SI_W_DPORT,
 			       NAT_OUTBOUND);
+		MUTEX_EXIT(&ipf_nat_new);
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, IPN_UDP);
-			nat_update(&fi, nat2, nat2->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 
 			(void) fr_addstate(&fi, NULL, SI_W_DPORT);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 	}
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_rcmd_pxy.c sys/contrib/ipfilter/netinet/ip_rcmd_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_rcmd_pxy.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_rcmd_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -154,8 +151,6 @@
 	 * other way.
 	 */
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_flx |= FI_IGNORE;
 	fi.fin_data[0] = sp;
 	fi.fin_data[1] = 0;
@@ -195,19 +190,21 @@
 			nflags |= NAT_NOTRULEPORT;
 		}
 
+		MUTEX_ENTER(&ipf_nat_new);
 		nat2 = nat_new(&fi, nat->nat_ptr, NULL, nflags, nat->nat_dir);
+		MUTEX_EXIT(&ipf_nat_new);
 
 		if (nat2 != NULL) {
 			(void) nat_proto(&fi, nat2, IPN_TCP);
-			nat_update(&fi, nat2, nat2->nat_ptr);
+			MUTEX_ENTER(&nat2->nat_lock);
+			nat_update(&fi, nat2);
+			MUTEX_EXIT(&nat2->nat_lock);
 			fi.fin_ifp = NULL;
 			if (nat->nat_dir == NAT_INBOUND) {
 				fi.fin_fi.fi_daddr = nat->nat_inip.s_addr;
 				ip->ip_dst = nat->nat_inip;
 			}
 			(void) fr_addstate(&fi, NULL, SI_W_DPORT);
-			if (fi.fin_state != NULL)
-				fr_statederef((ipstate_t **)&fi.fin_state);
 		}
 		ip->ip_len = slen;
 		ip->ip_src = swip;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_rpcb_pxy.c sys/contrib/ipfilter/netinet/ip_rpcb_pxy.c
--- sys.orig/contrib/ipfilter/netinet/ip_rpcb_pxy.c	2007-10-18 23:42:37.000000000 +0200
+++ sys/contrib/ipfilter/netinet/ip_rpcb_pxy.c	2011-04-27 13:03:01.000000000 +0200
@@ -916,14 +916,14 @@
 		/* There must be only one 4 byte argument. */
 		if (!RPCB_BUF_EQ(rm, p, 4))
 			return(-1);
-		
+
 		rr->rr_v2 = p;
 		xdr = B(rr->rr_v2);
-		
+
 		/* Reply w/ a 0 port indicates service isn't registered */
 		if (xdr == 0)
 			return(0);
-		
+
 		/* Is the value sane? */
 		if (xdr > 65535)
 			return(-1);
@@ -1122,7 +1122,7 @@
 	else {
 		return(-1);
 	}
-	
+
 	/* Advance past the string. */
 	(*p)++;
 
@@ -1159,8 +1159,6 @@
 
 	/* Generate dummy fr_info */
 	bcopy((char *)fin, (char *)&fi, sizeof(fi));
-	fi.fin_state = NULL;
-	fi.fin_nat = NULL;
 	fi.fin_out = 0;
 	fi.fin_src = fin->fin_dst;
 	fi.fin_dst = nat->nat_outip;
@@ -1241,8 +1239,10 @@
 		*ipn->in_plabel = '\0';
 
 		/* Create NAT entry.  return NULL if this fails. */
+		MUTEX_ENTER(&ipf_nat_new);
 		natl = nat_new(&fi, ipn, NULL, nflags|SI_CLONE|NAT_SLAVE,
 			       NAT_INBOUND);
+		MUTEX_EXIT(&ipf_nat_new);
 
 		bcopy((char *)&ipnat, (char *)ipn, sizeof(ipnat));
 
@@ -1253,14 +1253,15 @@
 
 		ipn->in_use++;
 		(void) nat_proto(&fi, natl, nflags);
-		nat_update(&fi, natl, natl->nat_ptr);
+		MUTEX_ENTER(&natl->nat_lock);
+		nat_update(&fi, natl);
+		MUTEX_EXIT(&natl->nat_lock);
 	}
 	MUTEX_DOWNGRADE(&ipf_nat);
 
 	if (is == NULL) {
 		/* Create state entry.  Return NULL if this fails. */
 		fi.fin_dst = nat->nat_inip;
-		fi.fin_nat = (void *)natl;
 		fi.fin_flx |= FI_NATED;
 		fi.fin_flx &= ~FI_STATE;
 		nflags &= NAT_TCPUDP;
@@ -1276,8 +1277,6 @@
 			 */
 			return(-1);
 		}
-		if (fi.fin_state != NULL)
-			fr_statederef((ipstate_t **)&fi.fin_state);
 	}
 
 	return(0);
@@ -1336,7 +1335,7 @@
 
 	/* Write new string. */
 	COPYBACK(m, off, xlen, uaddr);
-	
+
 	/* Determine difference in data lengths. */
 	diff = xlen - XDRALIGN(B(rr->rr_v3.xu_xslen));
 
diff -ur sys.orig/contrib/ipfilter/netinet/ip_rules.c sys/contrib/ipfilter/netinet/ip_rules.c
--- sys.orig/contrib/ipfilter/netinet/ip_rules.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_rules.c	2011-04-27 13:03:01.000000000 +0200
@@ -8,11 +6,22 @@
 * to the original author and the contributors.
 */
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/socket.h>
-#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__sgi)
-# include <sys/systm.h>
+#if (__FreeBSD_version >= 40000)
+# if defined(_KERNEL)
+#  include <sys/libkern.h>
+# else
+#  include <sys/unistd.h>
+# endif
+#endif
+#if (__NetBSD_Version__ >= 399000000)
+#else
+# if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__sgi)
+#  include <sys/systm.h>
+# endif
 #endif
 #include <sys/errno.h>
 #include <sys/param.h>
@@ -41,11 +50,11 @@
 #ifdef IPFILTER_COMPILED
 
 static u_long in_rule__0[] = {
-0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xffffffff, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000, 0x8002, 0, 0, 0, 0xffff, 0, 0, 0x4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+0, 0, 0, 0, 0, 0, 0, 0, 0xffffffff, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000, 0x8002, 0, 0, 0, 0xffff, 0, 0, 0x4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
 static u_long out_rule__0[] = {
-0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xffffffff, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000, 0x4002, 0, 0, 0, 0xffff, 0, 0, 0x4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+0, 0, 0, 0, 0, 0, 0, 0, 0xffffffff, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000, 0x4002, 0, 0, 0, 0xffff, 0, 0, 0x4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
 frentry_t *ipf_rules_in_[1] = {
@@ -62,10 +71,6 @@
 	return fr;
 }
 
-frentry_t *ipf_rules_out_[1] = {
-	(frentry_t *)&out_rule__0
-};
-
 frentry_t *ipfrule_match_out_(fin, passp)
 fr_info_t *fin;
 u_32_t *passp;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_state.c sys/contrib/ipfilter/netinet/ip_state.c
--- sys.orig/contrib/ipfilter/netinet/ip_state.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_state.c	2011-04-27 13:03:01.000000000 +0200
@@ -72,7 +72,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -128,11 +127,16 @@
 static ipstate_t *fr_matchsrcdst __P((fr_info_t *, ipstate_t *, i6addr_t *,
 				      i6addr_t *, tcphdr_t *, u_32_t));
 static ipstate_t *fr_checkicmpmatchingstate __P((fr_info_t *));
-static int fr_state_flush __P((int, int));
 static int fr_state_flush_entry __P((void *));
 static ips_stat_t *fr_statetstats __P((void));
 static int fr_delstate __P((ipstate_t *, int));
 static int fr_state_remove __P((caddr_t));
+static int ipf_state_match __P((ipstate_t *is1, ipstate_t *is2));
+static int ipf_state_matchaddresses __P((ipstate_t *is1, ipstate_t *is2));
+static int ipf_state_matchipv4addrs __P((ipstate_t *is1, ipstate_t *is2));
+static int ipf_state_matchipv6addrs __P((ipstate_t *is1, ipstate_t *is2));
+static int ipf_state_matchisps __P((ipstate_t *is1, ipstate_t *is2));
+static int ipf_state_matchports __P((udpinfo_t *is1, udpinfo_t *is2));
 static void fr_ipsmove __P((ipstate_t *, u_int));
 static int fr_tcpstate __P((fr_info_t *, tcphdr_t *, ipstate_t *));
 static int fr_tcpoptions __P((fr_info_t *, tcphdr_t *, tcpdata_t *));
@@ -140,7 +144,7 @@
 static void fr_fixinisn __P((fr_info_t *, ipstate_t *));
 static void fr_fixoutisn __P((fr_info_t *, ipstate_t *));
 static void fr_checknewisn __P((fr_info_t *, ipstate_t *));
-static int fr_stateiter __P((ipftoken_t *, ipfgeniter_t *));
+static int fr_stateiter __P((ipftoken_t *, ipfgeniter_t *, ipfobj_t *));
 static int fr_stgettable __P((char *));
 
 int fr_stputent __P((caddr_t));
@@ -412,7 +416,7 @@
 	int error;
 
 	sp = &st;
-	error = fr_inobj(data, &st, IPFOBJ_IPSTATE);
+	error = fr_inobj(data, NULL, &st, IPFOBJ_IPSTATE);
 	if (error)
 		return EFAULT;
 
@@ -421,7 +425,7 @@
 		if ((sp->is_p == st.is_p) && (sp->is_v == st.is_v) &&
 		    !bcmp((caddr_t)&sp->is_src, (caddr_t)&st.is_src,
 			  sizeof(st.is_src)) &&
-		    !bcmp((caddr_t)&sp->is_dst, (caddr_t)&st.is_src,
+		    !bcmp((caddr_t)&sp->is_dst, (caddr_t)&st.is_dst,
 			  sizeof(st.is_dst)) &&
 		    !bcmp((caddr_t)&sp->is_ps, (caddr_t)&st.is_ps,
 			  sizeof(st.is_ps))) {
@@ -600,18 +604,25 @@
 	    {
 		ipftoken_t *token;
 		ipfgeniter_t iter;
+		ipfobj_t obj;
 
-		error = fr_inobj(data, &iter, IPFOBJ_GENITER);
+		error = fr_inobj(data, &obj, &iter, IPFOBJ_GENITER);
 		if (error != 0)
 			break;
 
 		SPL_SCHED(s);
 		token = ipf_findtoken(IPFGENITER_STATE, uid, ctx);
-		if (token != NULL)
-			error = fr_stateiter(token, &iter);
-		else
+		if (token != NULL) {
+			error = fr_stateiter(token, &iter, &obj);
+			WRITE_ENTER(&ipf_tokens);
+			if (token->ipt_data == NULL)
+				ipf_freetoken(token);
+			else
+				ipf_dereftoken(token);
+			RWLOCK_EXIT(&ipf_tokens);
+		} else {
 			error = ESRCH;
-		RWLOCK_EXIT(&ipf_tokens);
+		}
 		SPL_X(s);
 		break;
 	    }
@@ -661,7 +672,7 @@
 	ipstate_save_t ips;
 	int error;
 
-	error = fr_inobj(data, &ips, IPFOBJ_STATESAVE);
+	error = fr_inobj(data, NULL, &ips, IPFOBJ_STATESAVE);
 	if (error != 0)
 		return error;
 
@@ -720,7 +731,7 @@
 	frentry_t *fr;
 	char *name;
 
-	error = fr_inobj(data, &ips, IPFOBJ_STATESAVE);
+	error = fr_inobj(data, NULL, &ips, IPFOBJ_STATESAVE);
 	if (error)
 		return EFAULT;
 
@@ -899,6 +910,205 @@
 
 
 /* ------------------------------------------------------------------------ */
+/* Function:    ipf_state_matchipv4addrs                                          */
+/* Returns:     int - 2 addresses match (strong match), 1 reverse match,    */
+/*                    0 no match                                            */
+/* Parameters:  is1, is2 pointers to states we are checking                 */
+/*                                                                          */
+/* Function matches IPv4 addresses it returns strong match for ICMP proto   */
+/* even there is only reverse match                                         */
+/* ------------------------------------------------------------------------ */
+static int
+ipf_state_matchipv4addrs(is1, is2)
+	ipstate_t *is1, *is2;
+{
+	int	rv;
+
+	if (is1->is_saddr == is2->is_saddr && is1->is_daddr == is2->is_daddr)
+		rv = 2;
+	else if (is1->is_saddr == is2->is_daddr &&
+	    is1->is_daddr == is2->is_saddr) {
+		/* force strong match for ICMP protocol */
+		rv = (is1->is_p == IPPROTO_ICMP) ? 2 : 1;
+	}
+	else
+		rv = 0;
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    ipf_state_matchipv6addrs                                          */
+/* Returns:     int - 2 addresses match (strong match), 1 reverse match,    */
+/*                    0 no match                                            */
+/* Parameters:  is1, is2 pointers to states we are checking                 */
+/*                                                                          */
+/* Function matches IPv6 addresses it returns strong match for ICMP proto   */
+/* even there is only reverse match                                         */
+/* ------------------------------------------------------------------------ */
+static int
+ipf_state_matchipv6addrs(is1, is2)
+	ipstate_t *is1, *is2;
+{
+	int	rv;
+
+	if (IP6_EQ(&is1->is_src, &is2->is_src) &&
+	    IP6_EQ(&is1->is_dst, &is2->is_dst))
+		rv = 2;
+	else if (IP6_EQ(&is1->is_src, &is2->is_dst) &&
+	    IP6_EQ(&is1->is_dst, &is2->is_src)) {
+		/* force strong match for ICMPv6 protocol */
+		rv = (is1->is_p == IPPROTO_ICMPV6) ? 2 : 1;
+	}
+	else
+		rv = 0;
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    ipf_state_matchaddresses                                          */
+/* Returns:     int - 2 addresses match, 1 reverse match, zero no match     */
+/* Parameters:  is1, is2 pointers to states we are checking                 */
+/*                                                                          */
+/* function retruns true if two pairs of addresses belong to single         */
+/* connection. suppose there are two endpoints:                             */
+/*      endpoint1 1.1.1.1                                                   */
+/*      endpoint2 1.1.1.2                                                   */
+/*                                                                          */
+/* the state is established by packet flying from .1 to .2 so we see:       */
+/*      is1->src = 1.1.1.1                                                  */
+/*      is1->dst = 1.1.1.2                                                  */
+/* now endpoint 1.1.1.2 sends answer                                        */
+/* retreives is1 record created by first packat and compares it with is2    */
+/* temporal record, is2 is initialized as follows:                          */
+/*      is2->src = 1.1.1.2                                                  */
+/*      is2->dst = 1.1.1.1                                                  */
+/* in this case 1 will be returned                                          */
+/*                                                                          */
+/* the ipf_matchaddresses() assumes those two records to be same. of course */
+/* the ipf_matchaddresses() also assume records are same in case you pass   */
+/* identical arguments (i.e. ipf_matchaddress(is1, is1) would return 2      */
+/* ------------------------------------------------------------------------ */
+static int
+ipf_state_matchaddresses(is1, is2)
+	ipstate_t *is1, *is2;
+{
+	int	rv;
+
+	if (is1->is_v == 4) {
+		rv = ipf_state_matchipv4addrs(is1, is2);
+	}
+	else {
+		rv = ipf_state_matchipv6addrs(is1, is2);
+	}
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    ipf_matchports                                              */
+/* Returns:     int - 2 match, 1 rverse match, 0 no match                   */
+/* Parameters:  ppairs1, ppairs - src, dst ports we want to match           */
+/*                                                                          */
+/* performs the same match for isps members as for addresses                */
+/* ------------------------------------------------------------------------ */
+static int
+ipf_state_matchports(ppairs1, ppairs2)
+	udpinfo_t *ppairs1, *ppairs2;
+{
+	int	rv;
+
+	if (ppairs1->us_sport == ppairs2->us_sport &&
+	    ppairs1->us_dport == ppairs2->us_dport)
+		rv = 2;
+	else if (ppairs1->us_sport == ppairs2->us_dport &&
+		    ppairs1->us_dport == ppairs2->us_sport)
+		rv = 1;
+	else
+		rv = 0;
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    ipf_matchisps                                               */
+/* Returns:     int - nonzero if isps members match, 0 nomatch              */
+/* Parameters:  is1, is2 - states we want to match                          */
+/*                                                                          */
+/* performs the same match for isps members as for addresses                */
+/* ------------------------------------------------------------------------ */
+static int
+ipf_state_matchisps(is1, is2)
+	ipstate_t *is1, *is2;
+{
+	int	rv;
+
+	if (is1->is_p == is2->is_p) {
+		switch (is1->is_p)
+		{
+		case IPPROTO_TCP :
+		case IPPROTO_UDP :
+			/* greinfo_t can be also interprted as port pair */
+			rv = ipf_state_matchports(&is1->is_ps.is_us,
+						  &is2->is_ps.is_us);
+			break;
+
+		case IPPROTO_ICMP :
+		case IPPROTO_ICMPV6 :
+			/* force strong match for ICMP datagram. */
+			if (bcmp(&is1->is_ps, &is2->is_ps,
+				 sizeof(icmpinfo_t)) == 0)  {
+				rv = 2;
+			} else {
+				rv = 0;
+			}
+			break;
+
+		default:
+			rv = 0;
+		}
+	} else {
+		rv = 0;
+	}
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* Function:    ipf_state_match                                             */
+/* Returns:     int - nonzero match, zero no match                          */
+/* Parameters:  is1, is2 - states we want to match                          */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+static int ipf_state_match(is1, is2)
+ipstate_t *is1, *is2;
+{
+	int	rv;
+	int	addrmatch;
+	int	portmatch;
+
+	if (bcmp(&is1->is_pass, &is2->is_pass,
+		 offsetof(struct ipstate, is_authmsk) -
+		 offsetof(struct ipstate, is_pass)) == 0) {
+
+		portmatch = ipf_state_matchisps(is1, is2);
+		addrmatch = ipf_state_matchaddresses(is1, is2);
+		rv = (addrmatch != 0) && (addrmatch == portmatch);
+	} else {
+		rv = 0;
+	}
+
+	return (rv);
+}
+
+
+/* ------------------------------------------------------------------------ */
 /* Function:    fr_addstate                                                 */
 /* Returns:     ipstate_t* - NULL == failure, else pointer to new state     */
 /* Parameters:  fin(I)    - pointer to packet information                   */
@@ -929,8 +1139,19 @@
 	grehdr_t *gre;
 	int out;
 
-	if (fr_state_lock ||
-	    (fin->fin_flx & (FI_SHORT|FI_STATE|FI_FRAGBODY|FI_BAD)))
+	/*
+	 * If a packet that was created locally is trying to go out but we
+	 * do not match here here because of this lock, it is likely that
+	 * the policy will block it and return network unreachable back up
+	 * the stack. To mitigate this error, EAGAIN is returned instead,
+	 * telling the IP stack to try sending this packet again later.
+	 */
+	if (fr_state_lock) {
+		fin->fin_error = EAGAIN;
+		return NULL;
+	}
+
+	if (fin->fin_flx & (FI_SHORT|FI_STATE|FI_FRAGBODY|FI_BAD))
 		return NULL;
 
 	if ((fin->fin_flx & FI_OOW) && !(fin->fin_tcpf & TH_SYN))
@@ -1164,10 +1385,9 @@
 	 */
 	for (is = ips_table[is->is_hv % fr_statesize]; is != NULL;
 	     is = is->is_hnext) {
-		if (bcmp(&ips.is_src, &is->is_src,
-			 offsetof(struct ipstate, is_ps) -
-			 offsetof(struct ipstate, is_src)) == 0)
+		if (ipf_state_match(&ips, is) == 1) {
 			break;
+		}
 	}
 	if (is != NULL)
 		return NULL;
@@ -1239,12 +1459,7 @@
 		}
 	}
 
-	/*
-	 * It may seem strange to set is_ref to 2, but fr_check() will call
-	 * fr_statederef() after calling fr_addstate() and the idea is to
-	 * have it exist at the end of fr_check() with is_ref == 1.
-	 */
-	is->is_ref = 2;
+	is->is_ref = 1;
 	is->is_pass = pass;
 	is->is_pkts[0] = 0, is->is_bytes[0] = 0;
 	is->is_pkts[1] = 0, is->is_bytes[1] = 0;
@@ -1318,7 +1533,6 @@
 		ipstate_log(is, ISL_NEW);
 
 	RWLOCK_EXIT(&ipf_state);
-	fin->fin_state = is;
 	fin->fin_rev = IP6_NEQ(&is->is_dst, &fin->fin_daddr);
 	fin->fin_flx |= FI_STATE;
 	if (fin->fin_flx & FI_FRAG)
@@ -1446,7 +1660,7 @@
 	tcpdata_t  *fdata, *tdata;
 
 	source = !fin->fin_rev;
-	if (((is->is_flags & IS_TCPFSM) != 0) && (source == 1) && 
+	if (((is->is_flags & IS_TCPFSM) != 0) && (source == 1) &&
 	    (ntohs(is->is_sport) != fin->fin_data[0]))
 		source = 0;
 	fdata = &is->is_tcp.ts_data[!source];
@@ -1693,7 +1907,7 @@
 			 * accepted, even if it appears out of sequence.
 			 */
 			inseq = 1;
-		} else 
+		} else
 #endif
 		if (!(fdata->td_winflags &
 			    (TCP_WSCALE_SEEN|TCP_WSCALE_FIRST))) {
@@ -1770,6 +1984,14 @@
 	bcopy((char *)is, (char *)clone, sizeof(*clone));
 
 	MUTEX_NUKE(&clone->is_lock);
+	/*
+	 * It has not yet been placed on any timeout queue, so make sure
+	 * all of that data is zero'd out.
+	 */
+	clone->is_sti.tqe_pnext = NULL;
+	clone->is_sti.tqe_next = NULL;
+	clone->is_sti.tqe_ifq = NULL;
+	clone->is_sti.tqe_parent = clone;
 
 	clone->is_die = ONE_DAY + fr_ticks;
 	clone->is_state[0] = 0;
@@ -1799,7 +2021,7 @@
 	clone->is_flags &= ~SI_CLONE;
 	clone->is_flags |= SI_CLONED;
 	fr_stinsert(clone, fin->fin_rev);
-	clone->is_ref = 2;
+	clone->is_ref = 1;
 	if (clone->is_p == IPPROTO_TCP) {
 		(void) fr_tcp_age(&clone->is_sti, fin, ips_tqtqb,
 				  clone->is_flags);
@@ -1841,6 +2063,13 @@
 	u_32_t cflx;
 	void *ifp;
 
+	/*
+	 * If a connection is about to be deleted, no packets
+	 * are allowed to match it.
+	 */
+	if (is->is_sti.tqe_ifq == &ips_deletetq)
+		return NULL;
+
 	rev = IP6_NEQ(&is->is_dst, dst);
 	ifp = fin->fin_ifp;
 	out = fin->fin_out;
@@ -2434,13 +2663,6 @@
 		hvm = DOUBLE_HASH(hv);
 		for (isp = &ips_table[hvm]; ((is = *isp) != NULL); ) {
 			isp = &is->is_hnext;
-			/*
-			 * If a connection is about to be deleted, no packets
-			 * are allowed to match it.
-			 */
-			if (is->is_sti.tqe_ifq == &ips_deletetq)
-				continue;
-
 			if ((is->is_p != pr) || (is->is_v != v))
 				continue;
 			is = fr_matchsrcdst(fin, is, &src, &dst, NULL, FI_CMP);
@@ -2663,6 +2885,7 @@
 		fr_movequeue(tqe, tqe->tqe_ifq, ifq);
 
 	is->is_pkts[i]++;
+	fin->fin_pktnum = is->is_pkts[i] + is->is_icmppkts[i];
 	is->is_bytes[i] += fin->fin_plen;
 	MUTEX_EXIT(&is->is_lock);
 
@@ -2723,9 +2946,7 @@
 	 * Search the hash table for matching packet header info.
 	 */
 	ifq = NULL;
-	is = fin->fin_state;
-	if (is == NULL)
-		is = fr_stlookup(fin, tcp, &ifq);
+	is = fr_stlookup(fin, tcp, &ifq);
 	switch (fin->fin_p)
 	{
 #ifdef	USE_INET6
@@ -2777,10 +2998,14 @@
 	fr = is->is_rule;
 	if (fr != NULL) {
 		if ((fin->fin_out == 0) && (fr->fr_nattag.ipt_num[0] != 0)) {
-			if (fin->fin_nattag == NULL)
+			if (fin->fin_nattag == NULL) {
+				RWLOCK_EXIT(&ipf_state);
 				return NULL;
-			if (fr_matchtag(&fr->fr_nattag, fin->fin_nattag) != 0)
+			}
+			if (fr_matchtag(&fr->fr_nattag, fin->fin_nattag) != 0) {
+				RWLOCK_EXIT(&ipf_state);
 				return NULL;
+			}
 		}
 		(void) strncpy(fin->fin_group, fr->fr_group, FR_GROUPLEN);
 		fin->fin_icode = fr->fr_icode;
@@ -2790,11 +3015,6 @@
 	pass = is->is_pass;
 	fr_updatestate(fin, is, ifq);
 
-	fin->fin_state = is;
-	is->is_touched = fr_ticks;
-	MUTEX_ENTER(&is->is_lock);
-	is->is_ref++;
-	MUTEX_EXIT(&is->is_lock);
 	RWLOCK_EXIT(&ipf_state);
 	fin->fin_flx |= FI_STATE;
 	if ((pass & FR_LOGFIRST) != 0)
@@ -2996,12 +3216,10 @@
 	is->is_ref = 0;
 
 	if (is->is_tqehead[0] != NULL) {
-		if (fr_deletetimeoutqueue(is->is_tqehead[0]) == 0)
-			fr_freetimeoutqueue(is->is_tqehead[0]);
+		(void) fr_deletetimeoutqueue(is->is_tqehead[0]);
 	}
 	if (is->is_tqehead[1] != NULL) {
-		if (fr_deletetimeoutqueue(is->is_tqehead[1]) == 0)
-			fr_freetimeoutqueue(is->is_tqehead[1]);
+		(void) fr_deletetimeoutqueue(is->is_tqehead[1]);
 	}
 
 #ifdef	IPFILTER_SYNC
@@ -3078,9 +3296,7 @@
 			fr_delstate(is, ISL_EXPIRE);
 		}
 
-	for (ifq = ips_utqe; ifq != NULL; ifq = ifqnext) {
-		ifqnext = ifq->ifq_next;
-
+	for (ifq = ips_utqe; ifq != NULL; ifq = ifq->ifq_next) {
 		for (tqn = ifq->ifq_head; ((tqe = tqn) != NULL); ) {
 			if (tqe->tqe_die > fr_ticks)
 				break;
@@ -3126,7 +3342,7 @@
 /*            If that too fails, then work backwards in 30 second intervals */
 /*            for the last 30 minutes to at worst 30 seconds idle.          */
 /* ------------------------------------------------------------------------ */
-static int fr_state_flush(which, proto)
+int fr_state_flush(which, proto)
 int which, proto;
 {
 	ipftq_t *ifq, *ifqnext;
@@ -3198,7 +3414,7 @@
 	case 2 :
 		break;
 
-		/*  
+		/*
 		 * Args 5-11 correspond to flushing those particular states
 		 * for TCP connections.
 		 */
@@ -3223,7 +3439,7 @@
 		if (which < 30)
 			break;
 
-		/* 
+		/*
 		 * Take a large arbitrary number to mean the number of seconds
 		 * for which which consider to be the maximum value we'll allow
 		 * the expiration to be.
@@ -3276,7 +3492,7 @@
 void *entry;
 {
 	return fr_delstate(entry, ISL_FLUSH);
-}     
+}
 
 
 /* ------------------------------------------------------------------------ */
@@ -3344,17 +3560,20 @@
 	dir = fin->fin_rev;
 	tcpflags = tcp->th_flags;
 	dlen = fin->fin_dlen - (TCP_OFF(tcp) << 2);
+	ostate = tqe->tqe_state[1 - dir];
+	nstate = tqe->tqe_state[dir];
 
 	if (tcpflags & TH_RST) {
 		if (!(tcpflags & TH_PUSH) && !dlen)
 			nstate = IPF_TCPS_CLOSED;
 		else
 			nstate = IPF_TCPS_CLOSE_WAIT;
+
+		if (ostate <= IPF_TCPS_ESTABLISHED) {
+			tqe->tqe_state[1 - dir] = IPF_TCPS_CLOSE_WAIT;
+		}
 		rval = 1;
 	} else {
-		ostate = tqe->tqe_state[1 - dir];
-		nstate = tqe->tqe_state[dir];
-
 		switch (nstate)
 		{
 		case IPF_TCPS_LISTEN: /* 0 */
@@ -4015,12 +4234,6 @@
 	if (is->is_ref > 1) {
 		is->is_ref--;
 		MUTEX_EXIT(&is->is_lock);
-#ifndef	_KERNEL
-		if ((is->is_sti.tqe_state[0] > IPF_TCPS_ESTABLISHED) ||
-		   (is->is_sti.tqe_state[1] > IPF_TCPS_ESTABLISHED)) {
-			fr_delstate(is, ISL_ORPHAN);
-		}
-#endif
 		return;
 	}
 	MUTEX_EXIT(&is->is_lock);
@@ -4109,9 +4322,10 @@
 /* This function handles the SIOCGENITER ioctl for the state tables and     */
 /* walks through the list of entries in the state table list (ips_list.)    */
 /* ------------------------------------------------------------------------ */
-static int fr_stateiter(token, itp)
+static int fr_stateiter(token, itp, obj)
 ipftoken_t *token;
 ipfgeniter_t *itp;
+ipfobj_t *obj;
 {
 	ipstate_t *is, *next, zero;
 	int error, count;
@@ -4126,63 +4340,72 @@
 	if (itp->igi_type != IPFGENITER_STATE)
 		return EINVAL;
 
-	is = token->ipt_data;
-	if (is == (void *)-1) {
-		ipf_freetoken(token);
-		return ESRCH;
-	}
-
 	error = 0;
-	dst = itp->igi_data;
+	obj->ipfo_type = IPFOBJ_IPSTATE;
+	obj->ipfo_size = sizeof(ipstate_t);
 
 	READ_ENTER(&ipf_state);
+
+	/*
+	 * Get "previous" entry from the token, and find the next entry
+	 * to be processed.
+	 */
+	is = token->ipt_data;
 	if (is == NULL) {
 		next = ips_list;
 	} else {
 		next = is->is_next;
 	}
 
-	count = itp->igi_nitems;
-	for (;;) {
+	dst = itp->igi_data;
+	for (count = itp->igi_nitems; count > 0; count--) {
+		/*
+		 * If we found an entry, add a reference and update the token.
+		 * Otherwise, zero out data to be returned and NULL out token.
+		 */
 		if (next != NULL) {
-			/*
-			 * If we find a state entry to use, bump its
-			 * reference count so that it can be used for
-			 * is_next when we come back.
-			 */
-			if (count == 1) {
-				MUTEX_ENTER(&next->is_lock);
-				next->is_ref++;
-				MUTEX_EXIT(&next->is_lock);
-				token->ipt_data = next;
-			}
+			MUTEX_ENTER(&next->is_lock);
+			next->is_ref++;
+			MUTEX_EXIT(&next->is_lock);
+			token->ipt_data = next;
 		} else {
 			bzero(&zero, sizeof(zero));
 			next = &zero;
-			count = 1;
 			token->ipt_data = NULL;
 		}
+
+		/*
+		 * Safe to release lock now the we have a reference.
+		 */
 		RWLOCK_EXIT(&ipf_state);
 
+		obj->ipfo_ptr = dst;
 		/*
-		 * This should arguably be via fr_outobj() so that the state
-		 * structure can (if required) be massaged going out.
+		 * Copy out data and clean up references and tokens.
 		 */
-		error = COPYOUT(next, dst, sizeof(*next));
+		error = fr_outobjk(obj, next);
 		if (error != 0)
 			error = EFAULT;
-		if ((count == 1) || (error != 0))
+
+		if (is != NULL)
+			fr_statederef(&is);
+
+		if (token->ipt_data != NULL) {
 			break;
+		} else {
+			if (next->is_next == NULL) {
+				token->ipt_data = NULL;
+				break;
+			}
+		}
 
-		dst += sizeof(*next);
-		count--;
+		if ((count == 1) || (error != 0))
+			break;
 
 		READ_ENTER(&ipf_state);
-		next = next->is_next;
-	}
-
-	if (is != NULL) {
-		fr_statederef(&is);
+		dst += sizeof(*next);
+		is = next;
+		next = is->is_next;
 	}
 
 	return error;
@@ -4203,14 +4426,14 @@
 	ipftable_t table;
 	int error;
 
-	error = fr_inobj(data, &table, IPFOBJ_GTABLE);
+	error = fr_inobj(data, NULL, &table, IPFOBJ_GTABLE);
 	if (error != 0)
 		return error;
 
 	if (table.ita_type != IPFTABLE_BUCKETS)
 		return EINVAL;
 
-	error = COPYOUT(ips_stats.iss_bucketlen, table.ita_table, 
+	error = COPYOUT(ips_stats.iss_bucketlen, table.ita_table,
 			fr_statesize * sizeof(u_long));
 	if (error != 0)
 		error = EFAULT;
diff -ur sys.orig/contrib/ipfilter/netinet/ip_state.h sys/contrib/ipfilter/netinet/ip_state.h
--- sys.orig/contrib/ipfilter/netinet/ip_state.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_state.h	2011-04-27 13:03:01.000000000 +0200
@@ -223,6 +220,7 @@
 extern	u_long	fr_tcplastack;
 extern	u_long	fr_tcptimeout;
 extern	u_long	fr_tcpclosed;
+extern	u_long	fr_tcptimewait;
 extern	u_long	fr_tcphalfclosed;
 extern	u_long	fr_udptimeout;
 extern	u_long	fr_udpacktimeout;
@@ -257,5 +255,6 @@
 extern	void	fr_updatestate __P((fr_info_t *, ipstate_t *, ipftq_t *));
 extern	void	fr_statederef __P((ipstate_t **));
 extern	void	fr_setstatequeue __P((ipstate_t *, int));
+extern	int	fr_state_flush __P((int, int));
 
 #endif /* __IP_STATE_H__ */
diff -ur sys.orig/contrib/ipfilter/netinet/ip_sync.c sys/contrib/ipfilter/netinet/ip_sync.c
--- sys.orig/contrib/ipfilter/netinet/ip_sync.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_sync.c	2011-04-27 13:03:01.000000000 +0200
@@ -32,6 +30,10 @@
 # if !defined(__SVR4) && !defined(__svr4__)
 #  include <sys/mbuf.h>
 # endif
+# include <sys/select.h>
+# if __FreeBSD_version >= 500000
+#  include <sys/selinfo.h>
+# endif
 #endif
 #if defined(__NetBSD__) && (__NetBSD_Version__ >= 104000000)
 # include <sys/proc.h>
@@ -64,7 +66,6 @@
 #ifdef sun
 # include <net/af.h>
 #endif
-#include <net/route.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
@@ -106,6 +107,10 @@
 #define	SYNC_NATTABSZ	256
 
 #ifdef	IPFILTER_SYNC
+# if SOLARIS && defined(_KERNEL)
+extern	struct pollhead	iplpollhead[IPL_LOGSIZE];
+# endif
+
 ipfmutex_t	ipf_syncadd, ipsl_mutex;
 ipfrwlock_t	ipf_syncstate, ipf_syncnat;
 #if SOLARIS && defined(_KERNEL)
@@ -284,11 +289,11 @@
 {
 	synchdr_t sh;
 
-	/* 
+	/*
 	 * THIS MUST BE SUFFICIENT LARGE TO STORE
-	 * ANY POSSIBLE DATA TYPE 
+	 * ANY POSSIBLE DATA TYPE
 	 */
-	char data[2048]; 
+	char data[2048];
 
 	int err = 0;
 
@@ -359,7 +364,7 @@
 
 
 		/*
-		 * We have a header, so try to read the amount of data 
+		 * We have a header, so try to read the amount of data
 		 * needed for the request
 		 */
 
@@ -402,7 +407,7 @@
 					sh.sm_len, uio->uio_resid);
 			return EAGAIN;
 		}
-	}	 
+	}
 
 	/* no more data */
 	return 0;
@@ -615,8 +620,8 @@
 		READ_ENTER(&ipf_state);
 
 		if (ipf_sync_debug > 6)
-			printf("[%d] Data from state v:%d p:%d cmd:%d table:%d rev:%d\n", 
-				sp->sm_num, sl->sl_hdr.sm_v, sl->sl_hdr.sm_p, 
+			printf("[%d] Data from state v:%d p:%d cmd:%d table:%d rev:%d\n",
+				sp->sm_num, sl->sl_hdr.sm_v, sl->sl_hdr.sm_p,
 				sl->sl_hdr.sm_cmd, sl->sl_hdr.sm_table,
 				sl->sl_hdr.sm_rev);
 
@@ -710,7 +715,7 @@
 	u_int hv = 0;
 	int err;
 
-	READ_ENTER(&ipf_syncstate);
+	READ_ENTER(&ipf_syncnat);
 
 	switch (sp->sm_cmd)
 	{
@@ -740,11 +745,11 @@
 		sl->sl_num = ntohl(sp->sm_num);
 
 		WRITE_ENTER(&ipf_nat);
-		sl->sl_pnext = syncstatetab + hv;
-		sl->sl_next = syncstatetab[hv];
-		if (syncstatetab[hv] != NULL)
-			syncstatetab[hv]->sl_pnext = &sl->sl_next;
-		syncstatetab[hv] = sl;
+		sl->sl_pnext = syncnattab + hv;
+		sl->sl_next = syncnattab[hv];
+		if (syncnattab[hv] != NULL)
+			syncnattab[hv]->sl_pnext = &sl->sl_next;
+		syncnattab[hv] = sl;
 		nat_insert(n, sl->sl_rev);
 		RWLOCK_EXIT(&ipf_nat);
 		break;
@@ -752,8 +757,7 @@
 	case SMC_UPDATE :
 		bcopy(data, &su, sizeof(su));
 
-		READ_ENTER(&ipf_syncstate);
-		for (sl = syncstatetab[hv]; (sl != NULL); sl = sl->sl_next)
+		for (sl = syncnattab[hv]; (sl != NULL); sl = sl->sl_next)
 			if (sl->sl_hdr.sm_num == sp->sm_num)
 				break;
 		if (sl == NULL) {
@@ -778,7 +782,7 @@
 		break;
 	}
 
-	RWLOCK_EXIT(&ipf_syncstate);
+	RWLOCK_EXIT(&ipf_syncnat);
 	return 0;
 }
 
@@ -821,16 +825,6 @@
 		ipf_syncwrap = 1;
 	}
 
-	hv = ipf_syncnum & (SYNC_STATETABSZ - 1);
-	while (ipf_syncwrap != 0) {
-		for (ss = syncstatetab[hv]; ss; ss = ss->sl_next)
-			if (ss->sl_hdr.sm_num == ipf_syncnum)
-				break;
-		if (ss == NULL)
-			break;
-		ipf_syncnum++;
-		hv = ipf_syncnum & (SYNC_STATETABSZ - 1);
-	}
 	/*
 	 * Use the synch number of the object as the hash key.  Should end up
 	 * with relatively even distribution over time.
@@ -839,9 +833,35 @@
 	 * nth connection they make, where n is a value in the interval
 	 * [0, SYNC_STATETABSZ-1].
 	 */
-	sl->sl_pnext = syncstatetab + hv;
-	sl->sl_next = syncstatetab[hv];
-	syncstatetab[hv] = sl;
+	 if (tab == SMC_STATE) {
+		hv = ipf_syncnum & (SYNC_STATETABSZ - 1);
+		while (ipf_syncwrap != 0) {
+			for (ss = syncstatetab[hv]; ss; ss = ss->sl_next)
+				if (ss->sl_hdr.sm_num == ipf_syncnum)
+					break;
+			if (ss == NULL)
+				break;
+			ipf_syncnum++;
+			hv = ipf_syncnum & (SYNC_STATETABSZ - 1);
+		}
+		sl->sl_pnext = syncstatetab + hv;
+		sl->sl_next = syncstatetab[hv];
+		syncstatetab[hv] = sl;
+	} else {
+		hv = ipf_syncnum & (SYNC_NATTABSZ - 1);
+		while (ipf_syncwrap != 0) {
+			for (ss = syncnattab[hv]; ss; ss = ss->sl_next)
+				if (ss->sl_hdr.sm_num == ipf_syncnum)
+					break;
+			if (ss == NULL)
+				break;
+			ipf_syncnum++;
+			hv = ipf_syncnum & (SYNC_STATETABSZ - 1);
+		}
+		sl->sl_pnext = syncnattab + hv;
+		sl->sl_next = syncnattab[hv];
+		syncnattab[hv] = sl;
+	}
 	sl->sl_num = ipf_syncnum;
 	MUTEX_EXIT(&ipf_syncadd);
 
@@ -855,12 +875,9 @@
 	if (tab == SMC_STATE) {
 		sl->sl_ips = ptr;
 		sz = sizeof(*sl->sl_ips);
-	} else if (tab == SMC_NAT) {
+	} else {
 		sl->sl_ipn = ptr;
 		sz = sizeof(*sl->sl_ipn);
-	} else {
-		ptr = NULL;
-		sz = 0;
 	}
 	sl->sl_len = sz;
 
@@ -888,12 +905,14 @@
 # if SOLARIS
 #  ifdef _KERNEL
 	cv_signal(&ipslwait);
+	pollwakeup(&iplpollhead[IPL_LOGSYNC], POLLIN|POLLRDNORM);
 #  endif
 	MUTEX_EXIT(&ipsl_mutex);
 # else
 	MUTEX_EXIT(&ipsl_mutex);
 #  ifdef _KERNEL
-	wakeup(&sl_tail);
+	WAKEUP(&sl_tail, 0);
+	POLLWAKEUP(IPL_LOGSYNC);
 #  endif
 # endif
 	return sl;
@@ -976,12 +995,14 @@
 # if SOLARIS
 #  ifdef _KERNEL
 	cv_signal(&ipslwait);
+	pollwakeup(&iplpollhead[IPL_LOGSYNC], POLLIN|POLLRDNORM);
 #  endif
 	MUTEX_EXIT(&ipsl_mutex);
 # else
 	MUTEX_EXIT(&ipsl_mutex);
 #  ifdef _KERNEL
-	wakeup(&sl_tail);
+	WAKEUP(&sl_tail, 0);
+	POLLWAKEUP(IPL_LOGSYNC);
 #  endif
 # endif
 }
diff -ur sys.orig/contrib/ipfilter/netinet/ipl.h sys/contrib/ipfilter/netinet/ipl.h
--- sys.orig/contrib/ipfilter/netinet/ipl.h	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ipl.h	2011-04-27 13:03:01.000000000 +0200
@@ -14,8 +14,8 @@
 #ifndef	__IPL_H__
 #define	__IPL_H__
 
-#define	IPL_VERSION	"IP Filter: v4.1.28"
+#define	IPL_VERSION	"IP Filter: v4.1.34"
 
-#define	IPFILTER_VERSION	4012800
+#define	IPFILTER_VERSION	4013400
 
 #endif
diff -ur sys.orig/contrib/ipfilter/netinet/mlfk_ipl.c sys/contrib/ipfilter/netinet/mlfk_ipl.c
--- sys.orig/contrib/ipfilter/netinet/mlfk_ipl.c	2010-12-21 18:09:25.000000000 +0100
+++ sys/contrib/ipfilter/netinet/mlfk_ipl.c	2011-04-27 13:03:01.000000000 +0200
@@ -18,7 +15,7 @@
 #include <sys/select.h>
 #if __FreeBSD_version >= 500000
 # include <sys/selinfo.h>
-#endif                  
+#endif
 #include <net/if.h>
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
@@ -216,11 +213,11 @@
 		defpass = "pass";
 	else if (FR_ISBLOCK(fr_pass))
 		defpass = "block";
-	else          
+	else
 		defpass = "no-match -> block";
 
 	printf("%s initialized.  Default = %s all, Logging = %s%s\n",
-		ipfilter_version, defpass,                
+		ipfilter_version, defpass,
 #ifdef IPFILTER_LOG
 		"enabled",
 #else
@@ -231,7 +228,7 @@
 #else
 		""
 #endif
-		);         
+		);
 	return 0;
 }
 
@@ -327,7 +324,7 @@
 
 	revents = 0;
 
-	switch (xmin) 
+	switch (xmin)
 	{
 	case IPL_LOGIPF :
 	case IPL_LOGNAT :
@@ -335,12 +332,12 @@
 #ifdef IPFILTER_LOG
 		if ((events & (POLLIN | POLLRDNORM)) && ipflog_canread(xmin))
 			revents |= events & (POLLIN | POLLRDNORM);
-#endif  
+#endif
 		break;
 	case IPL_LOGAUTH :
 		if ((events & (POLLIN | POLLRDNORM)) && fr_auth_waiting())
 			revents |= events & (POLLIN | POLLRDNORM);
-		break; 
+		break;
 	case IPL_LOGSYNC :
 #ifdef IPFILTER_SYNC
 		if ((events & (POLLIN | POLLRDNORM)) && ipfsync_canread())
